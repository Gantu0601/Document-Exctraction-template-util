@Slf4j
@ApplicationScoped
public class FinancialStatementTransformer {
    @Inject DynamoSubmissionStore store;
    @Inject S3Service s3Service;

    @SneakyThrows
    public String transform(SubmissionDocument document) {
        Uni<List<SubmissionResult>> resultsPromise = store.listResults(
                document.getOrgId(), document.getSubmissionId(), Prefix.RESULT_FINANCIAL_STATEMENT).collect().asList();

        SubmissionResult result = resultsPromise
                .onFailure()
                .retry()
                .withBackOff(Duration.ofMillis(100L), Duration.ofSeconds(1L))
                .atMost(5L)
                .await()
                .atMost(Duration.ofSeconds(100L))
                .stream()
                .filter(_result -> _result.getStatus().equals(SubmissionStatus.COMPLETED))
                .toList()
                .get(0);

        String rawResult = s3Service.getFile(result.getResultPath());

        ObjectMapper mapper = getObjectMapper();
        JsonNode response = mapper.readTree(rawResult);
        JsonNode detail = response.get("data").get("result");

        // Income Statement
        JsonNode incomeStatement = detail.get("income_statement");

        // prepare income statement data
        Map<String, Map<String, Double>> incomeSums = prepareIncomeStatement(incomeStatement);

        // Balance Sheet
        JsonNode balanceSheet = detail.get("financial_position");

        // prepare balance sheet data
        Map<String, Map<String, Double>> balanceSums = prepareBalanceSheet(balanceSheet);

        // Cash flows
        JsonNode cashFlows = detail.get("cash_flows");

        // prepare cash flows data
        Map<String, Map<String, Double>> cashFlowSums = prepareCashFlow(cashFlows);

        Map<String, Map<String, Double>> analysis = prepareAnalysis(incomeSums, balanceSums, incomeStatement.fieldNames(), balanceSheet.fieldNames());

        Map<String, Map<String, String>> formattedIncomeSums = formatValuesToString(incomeSums);
        Map<String, Map<String, String>> formattedCurrentAssetSums = formatValuesToString(balanceSums);
        Map<String, Map<String, String>> formattedCashFlowSums = formatValuesToString(cashFlowSums);
        Map<String, Map<String, String>> formattedAnalysis = formatValuesToString(analysis);

        // combine above 3 variable into one json file
        Map<String, Map<String, Map<String, String>>> transformedData = new HashMap<>();

        transformedData.put("incomeStatement", formattedIncomeSums);
        transformedData.put("balanceSheet", formattedCurrentAssetSums);
        transformedData.put("cashFlow", formattedCashFlowSums);
        transformedData.put("analysis", formattedAnalysis);

        String transformedJson = mapper.writeValueAsString(transformedData);
        String transformedJsonPath = TRANSFORMED_JSON.apply(document);
        s3Service.uploadJson(transformedJson, transformedJsonPath);

        // Upload transformed CSV
        if(document.getOrgId().equals(Prefix.RCBC.name())){
            String transformedCsv = transformToCsv(incomeSums, balanceSums, cashFlowSums);
            String transformedPathCsv = TRANSFORMED_CSV.apply(document);
            s3Service.uploadCsv(transformedCsv, transformedPathCsv);
        }else{
            String transformedPathXlsx = TRANSFORMED_XLSX.apply(document);
            transformToXlsx(document, transformedPathXlsx, transformedJson);
        }

//        return transform(rawResult);
        return transformedJsonPath;
    }

    private Map<String, Map<String, Double>> prepareAnalysis(Map<String, Map<String, Double>> incomeSums, Map<String, Map<String, Double>> balanceSums, Iterator<String> incomeStatementKeys, Iterator<String> balanceSheetKeys) {
        Map<String, Map<String, Double>> analysisSums = new HashMap<>();

        while (balanceSheetKeys.hasNext()) {
            String year = balanceSheetKeys.next();
            if (year.equals("note") || year.equals("notes")) {
                continue;
            }

            if (balanceSums.getOrDefault("current assets", new HashMap<>()).getOrDefault(year, 0d) == 0d ||
                    balanceSums.getOrDefault("current liabilities", new HashMap<>()).getOrDefault(year, 0d) == 0d) {
                analysisSums.computeIfAbsent("currentRatio", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("currentRatio", k -> new HashMap<>())
                        .merge(year, (
                                balanceSums.getOrDefault("current assets", new HashMap<>()).getOrDefault(year, 0d) /
                                        balanceSums.getOrDefault("current liabilities", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }

            if ((balanceSums.getOrDefault("current assets", new HashMap<>()).getOrDefault(year, 0d) -
                    balanceSums.getOrDefault("inventory", new HashMap<>()).getOrDefault(year, 0d)) == 0d ||
                    balanceSums.getOrDefault("current liabilities", new HashMap<>()).getOrDefault(year, 0d) == 0d) {
                analysisSums.computeIfAbsent("quickRatio", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("quickRatio", k -> new HashMap<>())
                        .merge(year, (
                                (balanceSums.getOrDefault("current assets", new HashMap<>()).getOrDefault(year, 0d) -
                                        balanceSums.getOrDefault("inventory", new HashMap<>()).getOrDefault(year, 0d)) /
                                        balanceSums.getOrDefault("current liabilities", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }

            if (balanceSums.getOrDefault("total liabilities", new HashMap<>()).getOrDefault(year, 0d) == 0d ||
                    balanceSums.getOrDefault("total equity", new HashMap<>()).getOrDefault(year, 0d) == 0d) {
                analysisSums.computeIfAbsent("liabilitiesToEquityRatio", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("liabilitiesToEquityRatio", k -> new HashMap<>())
                        .merge(year, (
                                balanceSums.getOrDefault("total liabilities", new HashMap<>()).getOrDefault(year, 0d) /
                                        balanceSums.getOrDefault("total equity", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }
        }

        while (incomeStatementKeys.hasNext()) {
            String year = incomeStatementKeys.next();
            if (year.equals("note") || year.equals("notes")) {
                continue;
            }

            String previousYear = String.valueOf(Integer.parseInt(year) - 1);

            if (incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(previousYear, 0d) == 0d) {
                analysisSums.computeIfAbsent("salesGrowth", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("salesGrowth", k -> new HashMap<>())
                        .merge(year, (
                                (incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(year, 0d) -
                                        incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(previousYear, 0d))/
                                        incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(previousYear, 0d)
                        ), Double::sum);
            }

            if (incomeSums.getOrDefault("net income", new HashMap<>()).getOrDefault(year, 0d) == 0d ||
                    (balanceSums.getOrDefault("total assets", new HashMap<>()).getOrDefault(year, 0d) == 0d &&
                            balanceSums.getOrDefault("total assets", new HashMap<>()).getOrDefault(previousYear, 0d) == 0d)) {
                analysisSums.computeIfAbsent("returnOnAssets", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("returnOnAssets", k -> new HashMap<>())
                        .merge(year, (
                                ((balanceSums.getOrDefault("total assets", new HashMap<>()).getOrDefault(year, 0d) +
                                        balanceSums.getOrDefault("total assets", new HashMap<>()).getOrDefault(previousYear, 0d))/2)/
                                        incomeSums.getOrDefault("net income", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }

            if (incomeSums.getOrDefault("net income", new HashMap<>()).getOrDefault(year, 0d) == 0d ||
                    (balanceSums.getOrDefault("total equity", new HashMap<>()).getOrDefault(year, 0d) == 0d &&
                            balanceSums.getOrDefault("total equity", new HashMap<>()).getOrDefault(previousYear, 0d) == 0d)) {
                analysisSums.computeIfAbsent("returnOnEquity", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("returnOnEquity", k -> new HashMap<>())
                        .merge(year, (
                                ((balanceSums.getOrDefault("total equity", new HashMap<>()).getOrDefault(year, 0d) +
                                        balanceSums.getOrDefault("total equity", new HashMap<>()).getOrDefault(previousYear, 0d))/2)/
                                        incomeSums.getOrDefault("net income", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }

            analysisSums.computeIfAbsent("netProfitMargin", k -> new HashMap<>())
                    .merge(year, (
                            incomeSums.getOrDefault("net income", new HashMap<>()).getOrDefault(year, 0d) /
                                    incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(year, 0d)
                    ), Double::sum);

            analysisSums.computeIfAbsent("grossMargin", k -> new HashMap<>())
                    .merge(year, (
                            incomeSums.getOrDefault("gross profit", new HashMap<>()).getOrDefault(year, 0d) /
                                    incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(year, 0d)
                    ), Double::sum);

            if (incomeSums.getOrDefault("operating profit", new HashMap<>()).getOrDefault(year, 0d) == 0d ||
                    incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(year, 0d) == 0d) {
                analysisSums.computeIfAbsent("operatingMargin", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("operatingMargin", k -> new HashMap<>())
                        .merge(year, (
                                incomeSums.getOrDefault("operating profit", new HashMap<>()).getOrDefault(year, 0d) /
                                        incomeSums.getOrDefault("sales", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }

            if (incomeSums.getOrDefault("operating expense", new HashMap<>()).getOrDefault(year, 0d) == 0d ||
                    incomeSums.getOrDefault("operating profit", new HashMap<>()).getOrDefault(year, 0d) == 0d) {
                analysisSums.computeIfAbsent("operatingEfficiencyRatio", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("operatingEfficiencyRatio", k -> new HashMap<>())
                        .merge(year, (
                                incomeSums.getOrDefault("operating expense", new HashMap<>()).getOrDefault(year, 0d) /
                                        incomeSums.getOrDefault("operating profit", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }

            if (incomeSums.getOrDefault("ebit", new HashMap<>()).getOrDefault(year, 0d) == 0d ||
                    incomeSums.getOrDefault("finance costs", new HashMap<>()).getOrDefault(year, 0d) == 0d) {
                analysisSums.computeIfAbsent("interestCoverageRatio", k -> new HashMap<>())
                        .merge(year, 0d, Double::sum);
            } else {
                analysisSums.computeIfAbsent("interestCoverageRatio", k -> new HashMap<>())
                        .merge(year, (
                                incomeSums.getOrDefault("ebit", new HashMap<>()).getOrDefault(year, 0d) /
                                        incomeSums.getOrDefault("finance costs", new HashMap<>()).getOrDefault(year, 0d)
                        ), Double::sum);
            }
        }

        return analysisSums;
    }


    private Map<String, Map<String, Double>> prepareIncomeStatement(JsonNode incomeStatement) {
        // Define keywords and their synonyms
        Map<String, List<String>> incomeKeywords = new HashMap<>();

        Iterator<String> incomeKeys = incomeStatement.fieldNames();

        // income statement
        incomeKeywords.put("sales", Arrays.asList("dividend income", "share in net income of associate", "interest income", "reversal of allowance", "other income", "revenue", "real estate sales", "rental income", "hotel operations", "equity share in net profits of associate", "net sales", "service income, net", "revenue on generation of solar power", "sales", "sale of real estates", "rental", "management fees", "net receipts"));
        incomeKeywords.put("cogs", Arrays.asList("cost of services", "cost of real estate sales", "cost of rental services", "cost of sales", "cost of sales and services", "cost of revenue"));
        incomeKeywords.put("operating expense", Arrays.asList("administrative cost", "operating expenses", "general and administrative expenses", "net impairment losses on financial assets", "impairment loss on goodwill", "other loss, net", "other income (loss), net", "taxes and licenses", "rental", "salaries and wages", "sss, philhealth & pag-ibig", "communication, light and water", "supplies expense", "representation expenses", "gasoline and oil", "depreciation", "miscellaneous", "repairs and maintenance", "light and water", "store and office supplies", "representation", "sss. phic and pag-ibig", "communication", "commissions", "rent expense", "distribution cost", "administrative cost", "administrative expenses", "professional fees", "subctiption, dues and fees", "taxes and licences", "impairment loss", "loss on earlt redemption - bonds", "salaries and wages", "representation", "rent", "communication, light and water", "depreciation and amortization", "miscellaneous", "hotel operations", "amortization", "subscription, dues and fees"));
        incomeKeywords.put("deprecation", Arrays.asList("depreciation and amortization", "depreciation", "amortization"));
        incomeKeywords.put("other expense income", Arrays.asList("gain on acquisition of business", "other income/expense", "expenses", "foreign exchange income (loss) on borrowings", "share in point (loss) of associates", "finance income", "share in net loss of associates", "impairment loss on financial assets", "other losses"));
        incomeKeywords.put("finance costs", Arrays.asList("finance costs", "finance cost", "interest expense", "foreign exchange income (loss) on borrowings"));
        incomeKeywords.put("interest expense", List.of("interest expense"));
        incomeKeywords.put("profit before tax", Arrays.asList("income before tax", "profit/(loss) before tax", "income before income tax from continuing operations", "net loss before income tax", "loss before income tax", "profit before tax", "net income before tax", "net income before income tax", "net income before tax other expense"));
        incomeKeywords.put("taxes", Arrays.asList("tax expense", "income tax expense", "provision for income tax", "income tax (expense) benefit", "less: provision for income tax"));
        incomeKeywords.put("other taxes", Arrays.asList("other taxes", "income from discounting operations"));

        incomeKeywords.put("net income", Arrays.asList("net income", "profit/(loss) for the year", "net loss after income tax", "income (loss) for the year", "net income after tax", "net profit", "net income after income tax", "profit for the year after tax"));
        incomeKeywords.put("adjustments", List.of("adjustments"));
        incomeKeywords.put("dividends", List.of("dividends"));
        incomeKeywords.put("retained earnings", Arrays.asList("retained earnings at the end of the year", "retained earnings", "net income"));

        Map<String, Map<String, Double>> incomeSums = new HashMap<>();

        // Process JSON
        processJsonNode(incomeStatement, incomeKeywords, incomeSums, "");

        // Balance sheet additional fields
        Map<String, List<String>> incomeMappings = new HashMap<>();
        incomeMappings.put("ebit", Arrays.asList("net income", "finance costs", "taxes"));
        incomeMappings.put("ebitda", Arrays.asList("net income", "finance costs", "taxes", "deprecation"));

        while (incomeKeys.hasNext()) {
            String year = incomeKeys.next();
            if (year.equals("note") || year.equals("notes")) {
                continue;
            }

            for (Map.Entry<String, List<String>> entry : incomeMappings.entrySet()) {
                String category = entry.getKey();
                List<String> components = entry.getValue();
                double sum = components.stream()
                        .mapToDouble(component -> incomeSums.getOrDefault(component, new HashMap<>()).getOrDefault(year, 0d))
                        .sum();
                incomeSums.computeIfAbsent(category, k -> new HashMap<>()).merge(year, sum, Double::sum);
            }
        }

        // calculate gross profit and add it to incomeSums
        for (String year : incomeSums.get("sales").keySet()) {
            if (year.equals("note") || year.equals("notes")) {
                continue;
            }

            double grossProfit = incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault(year, 0d) - incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault(year, 0d);
            double operatingProfit = grossProfit - incomeSums.get("operating expense").get(year);
            incomeSums.computeIfAbsent("gross profit", k -> new HashMap<>()).merge(year, grossProfit, Double::sum);
            incomeSums.computeIfAbsent("operating profit", k -> new HashMap<>()).merge(year, operatingProfit, Double::sum);
        }

        return incomeSums;
    }

    private Map<String, Map<String, Double>> prepareBalanceSheet(JsonNode balanceSheet) {
        // Define keywords and their synonyms
        Map<String, List<String>> balanceSheetKeywords = new HashMap<>();
        // all keys in balanceSheet
        Iterator<String> balanceSheetKeys = balanceSheet.fieldNames();

        // current assets
        balanceSheetKeywords.put("assets.current assets.|cash & cash equivalents", Arrays.asList("cash on hand and in banks", "cash", "cash and cash equivalents", "cash and balances with central banks", "cash and other cash items", "cash in hand (including foreign currency)", "cash and placements with central banks"));
        balanceSheetKeywords.put("assets.current assets.|accounts & other receivables", Arrays.asList("receivables", "current portion of trade and other receivables ", "trade and other receivables, net ", "accounts receivables", "receivables - net"));
        balanceSheetKeywords.put("assets.current assets.|loan receivables", Arrays.asList("loan receivables", "loans receivables", "loan receivable", "loans receivable"));
        balanceSheetKeywords.put("assets.current assets.|inventory", Arrays.asList("inventories", "inventory", "raw materials", "finished goods", "real estate inventories"));
        balanceSheetKeywords.put("assets.current assets.|other current assets", Arrays.asList("due from related parties", "prepaid income tax", "quarterly income tax", "contract assets - net", "deferred charges", "other current assets - net", "other current assets", "other current asset", "prepayments and other current assets"));
        // non-current assets
        balanceSheetKeywords.put("assets.non-current assets.|property, plant & equipment", Arrays.asList("property and equipment - net", "property, plant & equipment", "property and equipment, net ", "investment properties", "property, plant and equipment", "property and equipment at revalued amounts, net ", "property, plant and equipment at cost, net", "machinery and equipment", "delivery equipment", "office equipment ", "furnitures & fixtures", "less: accumulated depreciation ", "net book value", "property and equipment"));
        balanceSheetKeywords.put("assets.non-current assets.|investments", Arrays.asList("investments in subsidiaries", "investments in associates", "investments securities at fair value through oci", "investment in associates", "investments in associates", "investment properties - net"));
        balanceSheetKeywords.put("assets.non-current assets.|other non current assets", Arrays.asList("right-of-use asset, net", "loans receivables", "other non-current assets", "trade and other receivables - net of current portion", "goodwill", "other noncurrent assets", "other non-current asset", "right-of-use assets, net", "computer software, net", "other non-current assets, net", "receivables - net", "contract assets - net", "right-of-use assets", "other non-current assets - net", "other noncurrent asset", "rent deposit"));
        // non-current assets
        balanceSheetKeywords.put("assets.noncurrent assets.|property, plant & equipment", Arrays.asList("property and equipment - net", "property, plant & equipment", "property and equipment, net ", "investment properties", "property, plant and equipment", "property and equipment at revalued amounts, net ", "property, plant and equipment at cost, net", "machinery and equipment", "delivery equipment", "office equipment ", "furnitures & fixtures", "less: accumulated depreciation ", "net book value", "property and equipment"));
        balanceSheetKeywords.put("assets.noncurrent assets.|investments", Arrays.asList("investments in subsidiaries", "investments in associates", "investments securities at fair value through oci", "investment in associates", "investments in associates", "investment properties - net"));
        balanceSheetKeywords.put("assets.noncurrent assets.|other non current assets", Arrays.asList("right-of-use asset, net", "loans receivables", "other non-current assets", "trade and other receivables - net of current portion", "goodwill", "other noncurrent assets", "other non-current asset", "right-of-use assets, net", "computer software, net", "other non-current assets, net", "receivables - net", "contract assets - net", "right-of-use assets", "other non-current assets - net", "other noncurrent asset", "rent deposit"));
        // current liabilities
        balanceSheetKeywords.put("liabilities and equity.current liabilities.|short term debt", Arrays.asList("bonds payable", "current portion of loans payable", "short-term loans", "borrowings, current portion", "notes payable", "loan payable", "interest-bearing loans and borrowings"));
        balanceSheetKeywords.put("liabilities and equity.current liabilities.|accounts payable", Arrays.asList("trade and other payables", "due to related parties", "current portion of trade and other payables", "deposits from customers", "accounts payable and others", "advances from related parties", "advances from officers", "accounts payable", "contract liabilities", "customers' deposits", "accounts payable and accrued expenses"));
        balanceSheetKeywords.put("liabilities and equity.current liabilities.|other current", Arrays.asList("lease liability", "lease liabilities, current portion", "lease liabilities", "current tax liability", "income tax payable", "provision for income tax", "post-employment defined benefit obligation", "deferred tax liabilities - net"));
        // non-current liabilities
        balanceSheetKeywords.put("liabilities and equity.non-current liabilities.|long term debt", Arrays.asList("bonds payable", "debt", "loans payable - net of current portion", "loans payable", "notes payable", "borrowings liabilities, net of current portion", "interest-bearing loans and borrowings", "borrowings, net of current portion"));
        balanceSheetKeywords.put("liabilities and equity.non-current liabilities.|other non current liabilities", Arrays.asList("pension liability", "deferred tax liabilities, net", "other non-current liabilities", "deferred tax liability", "deferred income tax liabilities, net", "retirement benefit obligation ", "post-employment defined benefit obligation", "deferred tax liabilities -  net", "other noncurrent liabilities", "non-controlling interest", "lease liability", "lease liabilities, net of current portion", "lease liabilities", "trade and other payables - net of current portion", "trade payables, net of current portion", "trade and other payables"));
        // current liabilities
        balanceSheetKeywords.put("liabilities and equities.current liabilities.|short term debt", Arrays.asList("bonds payable", "current portion of loans payable", "short-term loans", "borrowings, current portion", "notes payable", "loan payable", "interest-bearing loans and borrowings"));
        balanceSheetKeywords.put("liabilities and equities.current liabilities.|accounts payable", Arrays.asList("trade and other payables", "due to related parties", "current portion of trade and other payables", "deposits from customers", "accounts payable and others", "advances from related parties", "advances from officers", "accounts payable", "contract liabilities", "customers' deposits", "accounts payable and accrued expenses"));
        balanceSheetKeywords.put("liabilities and equities.current liabilities.|other current", Arrays.asList("lease liability", "lease liabilities, current portion", "lease liabilities", "current tax liability", "income tax payable", "provision for income tax", "post-employment defined benefit obligation", "deferred tax liabilities - net"));
        // non-current liabilities
        balanceSheetKeywords.put("liabilities and equities.noncurrent liabilities.|long term debt", Arrays.asList("bonds payable", "debt", "loans payable - net of current portion", "loans payable", "notes payable", "borrowings liabilities, net of current portion", "interest-bearing loans and borrowings", "borrowings, net of current portion"));
        balanceSheetKeywords.put("liabilities and equities.noncurrent liabilities.|other non current liabilities", Arrays.asList("pension liability", "deferred tax liabilities, net", "other non-current liabilities", "deferred tax liability", "deferred income tax liabilities, net", "retirement benefit obligation ", "post-employment defined benefit obligation", "deferred tax liabilities -  net", "other noncurrent liabilities", "non-controlling interest", "lease liability", "lease liabilities, net of current portion", "lease liabilities", "trade and other payables - net of current portion", "trade payables, net of current portion", "trade and other payables"));
        // equity
        balanceSheetKeywords.put("equity.|stockholding", Arrays.asList("capital stock", "additional paid-in-capital", "additional paid-in capital", "share capital", "authorized 50,000 shares at p 100.0 par value", "paid-up capital", "equity attributable to shareholders of parent company", "susan i. honculada, capital at beginning of year"));
        balanceSheetKeywords.put("equity.|other equity", Arrays.asList("treasury shares, at cost", "revaluation reserve", "treasure shares", "revaluation surplus, net of tax", "cumulative translation difference", "fair value reserve on financial assets at fair value through other comprehensive income", "non-controlling interest"));
        balanceSheetKeywords.put("equity.|accumulated", Arrays.asList("retained earnings", "add: net income", "net income", "withdrawals", "cumulative earnings"));
        // equity
        balanceSheetKeywords.put("equities.|stockholding", Arrays.asList("capital stock", "additional paid-in-capital", "additional paid-in capital", "share capital", "authorized 50,000 shares at p 100.0 par value", "paid-up capital", "equity attributable to shareholders of parent company", "susan i. honculada, capital at beginning of year"));
        balanceSheetKeywords.put("equities.|other equity", Arrays.asList("treasury shares, at cost", "revaluation reserve", "treasure shares", "revaluation surplus, net of tax", "cumulative translation difference", "fair value reserve on financial assets at fair value through other comprehensive income", "non-controlling interest"));
        balanceSheetKeywords.put("equities.|accumulated", Arrays.asList("retained earnings", "add: net income", "net income", "withdrawals", "cumulative earnings"));

        Map<String, Map<String, Double>> balanceSums = new HashMap<>();

        // Process JSON
        processBalanceJsonNode(balanceSheet, balanceSheetKeywords, balanceSums, "");

        // Balance sheet additional fields
        Map<String, List<String>> balanceSheetMappings = new HashMap<>();
        balanceSheetMappings.put("current assets", Arrays.asList("cash & cash equivalents", "accounts & other receivables", "inventory", "other current assets"));
        balanceSheetMappings.put("non-current assets", Arrays.asList("property, plant & equipment", "investments", "other non current assets"));
        balanceSheetMappings.put("total assets", Arrays.asList("cash & cash equivalents", "accounts & other receivables", "inventory", "other current assets", "property, plant & equipment", "investments", "other non current assets"));
        balanceSheetMappings.put("current liabilities", Arrays.asList("short term debt", "accounts payable", "other current"));
        balanceSheetMappings.put("non-current liabilities", Arrays.asList("long term debt", "other non current liabilities"));
        balanceSheetMappings.put("total liabilities", Arrays.asList("short term debt", "accounts payable", "other current", "long term debt", "other non current liabilities"));
        balanceSheetMappings.put("total equity", Arrays.asList("stockholding", "other equity", "accumulated"));
        balanceSheetMappings.put("total liabilities & equity", Arrays.asList("short term debt", "accounts payable", "other current", "long term debt", "other non current liabilities", "stockholding", "other equity", "accumulated"));

        while (balanceSheetKeys.hasNext()) {
            String year = balanceSheetKeys.next();
            if (year.equals("note") || year.equals("notes")) {
                continue;
            }

            for (Map.Entry<String, List<String>> entry : balanceSheetMappings.entrySet()) {
                String category = entry.getKey();
                List<String> components = entry.getValue();
                double sum = components.stream()
                        .mapToDouble(component -> balanceSums.getOrDefault(component, new HashMap<>()).getOrDefault(year, 0d))
                        .sum();
                balanceSums.computeIfAbsent(category, k -> new HashMap<>()).merge(year, sum, Double::sum);
            }
        }

        return balanceSums;
    }

    private Map<String, Map<String, Double>> prepareCashFlow(JsonNode cashFlows) {
        Map<String, List<String>> cashFlowsKeywords = new HashMap<>();

        // all keys in cashFlows
        Iterator<String> cashFlowsKeys = cashFlows.fieldNames();

        // cash flow
        cashFlowsKeywords.put("cashflow from operations", Arrays.asList("operating loss before working capital changes", "operating income before working capital changes", "operating income before changes in working capital", "operating profit before changes in working capital", "operating profit before working capital changes"));
        cashFlowsKeywords.put("cashflow from investing", Arrays.asList("net cash provided by investing activities", "net cash provided by (used in) investing activities", "net cash used in investing activities", "net cash flows provided by (used in) financing activities", "net cash used in investing activities", "net cash used in investing activities", "cash flows from investing activities", "cash flows used in investing activities"));
        cashFlowsKeywords.put("cashflow from financing", Arrays.asList("net cash used in financing activities", "net cash provided by (used in) financing activites", "net cash provided by (used in) financing activities", "net cash provided by (used) financing activities", "net cash from financing activities", "cash flows from financing activities", "net cash flows provided by (used in) financing activities"));
        cashFlowsKeywords.put("net operating cash", Arrays.asList("net cash generated from (used in) operating activities", "net cash provided by (used in) operating activities", "net cash from (used in) operating activities", "net cash provided by operating activities", "net cash provided by operating activities", "cash provided by (used in) operating activities"));
        cashFlowsKeywords.put("cashflow from non-working capital", Arrays.asList("net cash provided by investing activities", "net cash provided by (used in) investing activities", "net cash used in investing activities", "net cash flows provided by (used in) financing activities", "net cash used in investing activities ", "net cash used in investing activities", "cash flows from investing activities", "cash flows used in investing activities", "net cash used in financing activities", "net cash provided by (used in) financing activites", "net cash provided by (used in) financing activities", "net cash provided by (used) financing activities", "net cash from financing activities", "cash flows from financing activities", "net cash flows provided by (used in) financing activities"));
        cashFlowsKeywords.put("cashflow after debt service", Arrays.asList("net increase (decrease) in cash on hand and in banks", "net increase/(decrease) in cash", "net increase (decrease) in cash on hand and in banks ", "net increase (decrease) in cash", "net increase (decrease) in cash and cash equivalents", "net increase in cash and cash equivalents"));
        cashFlowsKeywords.put("beginning cash", Arrays.asList("cash on hand and in banks at beginning of year", "cash at the beginning of the year", "cash balance at the beginning of the year", "cash at beginning of year", "cash and cash equivalents at beginning of year", "balance beginning of year"));
        cashFlowsKeywords.put("interest paid", List.of("interest paid"));

        Map<String, Map<String, Double>> cashFlowSums = new HashMap<>();

        processCashFlowJsonNode(cashFlows, cashFlowsKeywords, cashFlowSums, "");

        // cash flow additional fields
        while (cashFlowsKeys.hasNext()) {
            String year = cashFlowsKeys.next();
            if (year.equals("note") || year.equals("notes")) {
                continue;
            }

            cashFlowSums.computeIfAbsent("cashflow from working capital", k -> new HashMap<>()).merge(year, (
                    cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault(year, 0d) -
                            cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault(year, 0d) -
                            cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault(year, 0d)
            ), Double::sum);

            cashFlowSums.computeIfAbsent("cashflow before debt service", k -> new HashMap<>()).merge(year, (
                    cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault(year, 0d) -
                            cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault(year, 0d) +
                            cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault(year, 0d)
            ), Double::sum);

            cashFlowSums.computeIfAbsent("debt service", k -> new HashMap<>()).merge(year, (
                    cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault(year, 0d) -
                            (cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault(year, 0d) -
                                    cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault(year, 0d) +
                                    cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault(year, 0d))
            ), Double::sum);

            cashFlowSums.computeIfAbsent("net operating cash generated", k -> new HashMap<>()).merge(year, (
                    cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault(year, 0d) -
                            cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault(year, 0d)
            ), Double::sum);

            cashFlowSums.computeIfAbsent("ending cash balance", k -> new HashMap<>()).merge(year, (
                    cashFlowSums.getOrDefault("beginning cash", new HashMap<String, Double>()).getOrDefault(year, 0d) +
                            cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault(year, 0d) +
                            cashFlowSums.getOrDefault("cashflow from investing", new HashMap<String, Double>()).getOrDefault(year, 0d) +
                            cashFlowSums.getOrDefault("cashflow from financing", new HashMap<String, Double>()).getOrDefault(year, 0d)
            ), Double::sum);
        }

        return cashFlowSums;
    }

    @SneakyThrows
    public String transform(String content) {
        return toJson(TransformedResult.builder()
                .currentRatio(null)
                .quickRatio(null)
                .netProfitMargin(null)
                .returnOnAssets(null)
                .returnOnEquity(null)
                .grossMargin(null)
                .inventoryTurnover(null)
                .receivableTurnover(null)
                .assetTurnover(null)
                .debtToEquityRatio(null)
                .interestCoverageRatio(null)
                .cashFlowCoverageRatio(null)
                .build());
        /**
         ObjectMapper mapper = getObjectMapper();
         JsonNode response = mapper.readTree(content);
         JsonNode detail = response.get("data").get("statementDetails").get("result");

         JsonNode currentAssets = detail.get("current assets");
         JsonNode nonCurrentAssets = detail.get("non-current assets");
         JsonNode totalAssets = detail.get("total assets");

         JsonNode currentLiabilities = detail.get("current liabilities");
         JsonNode equity = detail.get("equity");
         JsonNode totalLiabilitiesAndEquity = detail.get("total liabilities and equity");

         JsonNode retainedEarnings = detail.get("retained earnings");

         JsonNode cashFlows = detail.get("cash flows");
         JsonNode adjustmentsFor = detail.get("adjustments for:");
         JsonNode decreaseIn = detail.get("decrease (increase) in:");
         JsonNode increaseIn = detail.get("increase (decrease) in:");

         String year = "2022";

         // Liquidity ratios
         Optional<Double> currentRatio = getCurrentRatio(currentAssets, currentLiabilities, year);
         Optional<Double> quickRatio = getQuickRatio(currentAssets, currentLiabilities, year);

         // Profitability ratios
         Optional<Double> netProfitMargin = getNetProfitMargin(retainedEarnings, year);
         Optional<Double> returnOnAssets = getReturnOnAssets(totalAssets, retainedEarnings, year);
         Optional<Double> returnOnEquity = getReturnOnEquity(retainedEarnings, equity, year);
         Optional<Double> grossMargin = getGrossMargin(retainedEarnings, year);

         // Efficiency ratios
         Optional<Double> inventoryTurnover = Optional.empty();
         Optional<Double> receivableTurnover = Optional.empty();
         Optional<Double> assetTurnover = Optional.empty();

         // Solvency ratios
         Optional<Double> debtToEquityRatio = getDebtToEquityRatio(currentLiabilities, equity, year);
         Optional<Double> interestCoverageRatio = getInterestCoverageRatio(retainedEarnings, year);
         Optional<Double> cashFlowCoverageRatio = getCashFlowCoverageRatio(cashFlows, currentLiabilities, year);

         TransformedResult transformedResult = TransformedResult.builder()
         .currentRatio(currentRatio.orElse(null))
         .quickRatio(quickRatio.orElse(null))
         .netProfitMargin(netProfitMargin.orElse(null))
         .returnOnAssets(returnOnAssets.orElse(null))
         .returnOnEquity(returnOnEquity.orElse(null))
         .grossMargin(grossMargin.orElse(null))
         .inventoryTurnover(inventoryTurnover.orElse(null))
         .receivableTurnover(receivableTurnover.orElse(null))
         .assetTurnover(assetTurnover.orElse(null))
         .debtToEquityRatio(debtToEquityRatio.orElse(null))
         .interestCoverageRatio(interestCoverageRatio.orElse(null))
         .cashFlowCoverageRatio(cashFlowCoverageRatio.orElse(null))
         .build();

         return toJson(transformedResult); **/
    }

    private static void processJsonNode(JsonNode node, Map<String, List<String>> keywords, Map<String, Map<String, Double>> yearSums, String currentPath) {
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                if (field.getKey().equalsIgnoreCase("note") || field.getKey().equalsIgnoreCase("notes")) {
                    // Skip processing for "note" or "notes"
                    continue;
                }
                String newPath = currentPath.isEmpty() ? field.getKey() : currentPath + "." + field.getKey();
                processJsonNode(field.getValue(), keywords, yearSums, newPath);
            }
        } else if (node.isValueNode()) {
            // Check if the current path matches any keyword or synonym and if it's associated with a year
            for (Map.Entry<String, List<String>> entry : keywords.entrySet()) {
                if (currentPath.contains("total")) continue;
                if ((entry.getKey().equals("taxes")) && currentPath.contains("expenses")) continue;
                if ((entry.getKey().equals("sales")) && currentPath.contains("cost of")) continue;
                if ((entry.getKey().equals("sales")) && currentPath.contains("net sales")) continue;
                if ((entry.getKey().equals("net income") || entry.getKey().equals("retained earnings")) && currentPath.contains("revenue")) continue;
                if (currentPath.contains(entry.getKey()) || entry.getValue().stream().anyMatch(
                        currentPath::contains)) {
                    String year = extractYearFromPath(currentPath);
                    if (!year.isEmpty()) {
                        double value = parseValue(node.asText());
                        yearSums.computeIfAbsent(entry.getKey(), k -> new HashMap<>()).merge(year, value, Double::sum);
                    }
                }
            }
        }
    }

    private static void processBalanceJsonNode(JsonNode node, Map<String, List<String>> keywords, Map<String, Map<String, Double>> yearSums, String currentPath) {
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                if (field.getKey().equalsIgnoreCase("note") || field.getKey().equalsIgnoreCase("notes")) {
                    // Skip processing for "note" or "notes"
                    continue;
                }
                String newPath = currentPath.isEmpty() ? field.getKey() : currentPath + "." + field.getKey();
                processBalanceJsonNode(field.getValue(), keywords, yearSums, newPath);
            }
        } else if (node.isValueNode()) {
            // Check if the current path matches any keyword or synonym and if it's associated with a year
            for (Map.Entry<String, List<String>> entry : keywords.entrySet()) {
                if (currentPath.contains("total")) continue;
//                if (entry.getKey().split("\\|")[1].contains("accounts & other receivables") && currentPath.contains("loan")) continue;

                if (currentPath.contains(entry.getKey().split("\\|")[0]) && entry.getValue().stream().anyMatch(
                        currentPath::contains)) {
                    String year = extractYearFromPath(currentPath);
                    if (!year.isEmpty()) {
                        double value = parseValue(node.asText());

                        yearSums.computeIfAbsent(entry.getKey().split("\\|")[1], k -> new HashMap<>()).merge(year, value, Double::sum);
                    }
                }
            }
        }
    }

    private static void processCashFlowJsonNode(JsonNode node, Map<String, List<String>> keywords, Map<String, Map<String, Double>> yearSums, String currentPath) {
        String year = "";
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                if (field.getKey().equalsIgnoreCase("note") || field.getKey().equalsIgnoreCase("notes")) {
                    // Skip processing for "note" or "notes"
                    continue;
                }

                if (field.getKey().matches("\\d{4}")) {
                    year = field.getKey();
                } else {
                    year = extractYearFromPath(currentPath);
                }
                String newPath = year + "." + field.getKey();
                processCashFlowJsonNode(field.getValue(), keywords, yearSums, newPath);
            }
        } else if (node.isValueNode()) {
            // Check if the current path matches any keyword or synonym and if it's associated with a year
            for (Map.Entry<String, List<String>> entry : keywords.entrySet()) {
                if (currentPath.contains("total")) continue;
                if (entry.getValue().stream().anyMatch(
                        currentPath::contains)) {
                    year = extractYearFromPath(currentPath);
                    if (!year.isEmpty()) {
                        double value = parseValue(node.asText());

                        yearSums.computeIfAbsent(entry.getKey(), k -> new HashMap<>()).merge(year, value, Double::sum);
                    }
                }
            }
        }
    }

    private static String extractYearFromPath(String path) {
        // Extract the year from the path (e.g., "2021", "2022", etc.)
        // Adjust the logic according to how years are represented in your JSON paths
        // Example logic: assume years are four digits and separated by a period
        String[] parts = path.split("\\.");
        for (String part : parts) {
            if (part.matches("\\d{4}")) {
                return part;
            }
        }
        return "";
    }

    private static double parseValue(String value) {
        // In case of "P" or peso sign, remove it
        value = value.replaceAll("â‚±", "").trim();
        value = value.replaceAll("P", "").trim();
        value = value.replaceAll("p", "").trim();

        // Parse the value considering "()" as negative, "-" as skip
        if (value.equals("-") || value.isEmpty()) {
            return 0.0;
        }
        try {
            if (value.startsWith("(") && value.endsWith(")")) {
                value = value.substring(1, value.length() - 1);
                return -Double.parseDouble(value.replaceAll(",", ""));
            }
            return Double.parseDouble(value.replaceAll(",", ""));
        } catch (NumberFormatException e) {
            return 0.0; // In case of invalid number format
        }
    }


    public boolean transformToXlsx(SubmissionDocument document, String outputFilePath, String transformedJson) {
        Map<String, String> keyMap = new LinkedHashMap<>();
        keyMap.put("current assets", "CURRENT ASSETS");
        keyMap.put("cash & cash equivalents", "Cash & Cash Equivalents");
        keyMap.put("accounts & other receivables", "Accounts & Other Receivables");
        keyMap.put("loan receivables", "Loan receivables");
        keyMap.put("---", "Inventory");
        keyMap.put("other current assets", "Other Current Assets");
        keyMap.put("non-current assets", "NON-CURRENT ASSETS");
        keyMap.put("property, plant & equipment", "Property, Plant & Equipment");
        keyMap.put("investments", "Investments");
        keyMap.put("other non current assets", "Other non current assets");
        keyMap.put("total assets", "TOTAL ASSET");
        keyMap.put("current liabilities", "CURRENT LIABILITIES");
        keyMap.put("short term debt", "Short term debt");
        keyMap.put("accounts payable", "Accounts Payable");
        keyMap.put("other current", "Other Current");
        keyMap.put("non-current liabilities", "NON-CURRENT LIABILITIES");
        keyMap.put("long term debt", "Long Term Debt");
        keyMap.put("other non current liabilities", "Other Non Current Liabilities");
        keyMap.put("total liabilities", "TOTAL LIABILITIES");
        keyMap.put("-", "EQUITY");
        keyMap.put("stockholding", "Common equity");
        keyMap.put("other equity", "Other Equity");
        keyMap.put("accumulated", "Retained earning");
        keyMap.put("total equity", "TOTAL EQUITY");
        keyMap.put("total liabilities & equity", "TOTAL LIABILITIES & EQUITY");

        // Define special labels to handle without associated JSON data
        Set<String> specialLabels = new HashSet<>();
        specialLabels.add("Inventory");
        specialLabels.add("EQUITY");

        Map<String, String> keyMaps2 = new LinkedHashMap<>();
        keyMaps2.put("sales", "SALES");
        keyMaps2.put("-", "COGS");
        keyMaps2.put("gross profit", "GROSS PROFIT");
        keyMaps2.put("operating expense", "OPERATING EXPENSES");
        keyMaps2.put("operating profit", "OPERATING PROFIT");
        keyMaps2.put("other expense income", "OTHER EXPENSE (INCOME)");
        keyMaps2.put("finance costs", "FINANCE COSTS");
        keyMaps2.put("profit before tax", "PROFIT BEFORE TAX");
        keyMaps2.put("taxes", "TAXES");
        keyMaps2.put("--", "OTHER TAXES");
        keyMaps2.put("net income", "NET INCOME");
        keyMaps2.put("", "");
        keyMaps2.put("ebit", "EBIT");
        keyMaps2.put("ebitda", "EBITDA");

        Map<String, String> keyMaps1 = new LinkedHashMap<>();
        keyMaps1.put("cashflow from operations", "CASHFLOW FROM OPERATING ACTIVITIES");
        keyMaps1.put("cashflow from investing", "CASHFLOW FROM INVESTING ACTIVITIES");
        keyMaps1.put("cashflow from financing", "CASHFLOW FROM FINANCING ACTIVITIES");
        keyMaps1.put("beginning cash", "BEGINNING CASH");
        keyMaps1.put("ending cash balance", "ENDING CASH");
        keyMaps1.put("", "");
        keyMaps1.put("cashflow after debt service", "CASHFLOW AFTER DEBT SERVICE");


        int columnWidth = 22;

        try {
            ObjectMapper mapper = new ObjectMapper();

            JsonNode response = mapper.readTree(transformedJson);
            JsonNode balanceSheet = response.get("balanceSheet");
            JsonNode incomeStatement = response.get("incomeStatement");
            JsonNode cashFlow = response.get("cashFlow");
            JsonNode salesGrowthNode = response.path("analysis").path("salesGrowth");
            JsonNode profitMarginNode = response.path("analysis").path("grossMargin");
            JsonNode operatingMarginNode = response.path("analysis").path("operatingMargin");
            JsonNode currentRatioNode = response.path("analysis").path("currentRatio");
            JsonNode ratioNode = response.path("analysis").path("liabilitiesToEquityRatio");
            JsonNode quickRatiosNode = response.path("analysis").path("quickRatio");
            JsonNode marginNode = response.path("analysis").path("netProfitMargin");
            JsonNode roaNode = response.path("analysis").path("returnOnAssets");
            JsonNode roeNode = response.path("analysis").path("returnOnEquity");
            JsonNode icrNode = response.path("analysis").path("interestCoverageRatio");
            JsonNode oerNode = response.path("analysis").path("operatingEfficiencyRatio");


            try (Workbook workbook = new XSSFWorkbook()) {

                // Create Sheets
                Sheet sheet = workbook.createSheet("Financial Statement Analysis Sheet");
                Sheet sheet1 = workbook.createSheet("Financial Ratios");

                // Create a Balance Sheet
                int rowIndex = populateSectionWithData(workbook, sheet, 0, "Balance Sheet", balanceSheet, keyMap);

                // Create an Income Statement
                rowIndex = populateSectionWithData(workbook, sheet, rowIndex + 2, "Income Statement", incomeStatement, keyMaps2);

                // Create a Cash Flow
                rowIndex = populateSectionWithData(workbook, sheet, rowIndex + 2, "Cash Flow", cashFlow, keyMaps1);

                // Adjust column widths
                for (int i = 0; i <= keyMap.size(); i++) {
                    sheet.setColumnWidth(0, columnWidth * 384);
                    sheet.setColumnWidth(1, columnWidth * 256);
                    sheet.setColumnWidth(2, columnWidth * 192);
                    sheet.setColumnWidth(3, columnWidth * 192);
                }

                // Create Current Sales Growth Line Chart
                DefaultCategoryDataset dataset = new DefaultCategoryDataset();

                // Collect years and growth rates into a list
                List<Map.Entry<String, JsonNode>> entries = new ArrayList<>();
                salesGrowthNode.fields().forEachRemaining(entries::add);

                // Iterate over entries in reverse order to populate the dataset
                for (int i = entries.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries.get(i);
                    String year = entry.getKey();
                    double growthRate = entry.getValue().asDouble();
                    dataset.addValue(growthRate,"", year);
                }

                JFreeChart chart = ChartFactory.createLineChart(
                        "Sales Growth",        // chart title
                        "Year",                // domain axis label
                        "Growth Rate",         // range axis label
                        dataset,               // data
                        PlotOrientation.VERTICAL,
                        false,                  // include legend
                        true,                  // tooltips
                        false                  // urls
                );

                // Customize chart properties
                chart.getTitle().setFont(chart.getTitle().getFont().deriveFont(14.0f));

                CategoryPlot plot = chart.getCategoryPlot();

                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis = plot.getDomainAxis();
                domainAxis.setLabel("");           // Hide domain axis label
                domainAxis.setTickLabelsVisible(true); // Show domain axis tick labels

                // Customize range axis (Y-axis) properties
                NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();
                rangeAxis.setLabel("");            // Hide range axis label
                rangeAxis.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Initialize variables to track minimum and maximum values
                double minValue = Double.POSITIVE_INFINITY;
                double maxValue = Double.NEGATIVE_INFINITY;

                // Iterate through the dataset to find the actual minimum and maximum values
                for (int i = 0; i < dataset.getRowCount(); i++) {
                    for (int j = 0; j < dataset.getColumnCount(); j++) {
                        Number value = dataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue < minValue) {
                                minValue = dataValue;
                            }
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }
                double margin = 0.2 * (maxValue - minValue);
                rangeAxis.setRange(minValue - margin, maxValue + margin);

                // Customize renderer to display values for all data points
                CategoryItemLabelGenerator labelGenerator = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                LineAndShapeRenderer renderer = (LineAndShapeRenderer) plot.getRenderer();
                renderer.setDefaultItemLabelGenerator(labelGenerator);
                renderer.setDefaultItemLabelsVisible(true);

                // Customize series appearance
                renderer.setSeriesPaint(0, new Color(44, 164, 255));
                renderer.setSeriesStroke(0, new BasicStroke(1.5f));
                renderer.setSeriesShapesVisible(0, true);
                renderer.setSeriesShapesFilled(0, true);
                renderer.setSeriesShape(0, new Ellipse2D.Double(-2.0, -2.0, 4.0, 4.0));
                renderer.setUseFillPaint(true);
                renderer.setSeriesLinesVisible(0, true);

                // Set background color
                plot.setBackgroundPaint(Color.WHITE);

                // Write the chart to a byte array
                byte[] chartBytes = ChartUtils.encodeAsPNG(chart.createBufferedImage(400, 240));

                // Add the chart image into the Excel file
                int pictureIdx = workbook.addPicture(chartBytes, Workbook.PICTURE_TYPE_PNG);
                CreationHelper helper = workbook.getCreationHelper();
                Drawing<?> drawing = sheet1.createDrawingPatriarch();
                ClientAnchor anchor = helper.createClientAnchor();
                anchor.setCol1(0);
                anchor.setRow1(0);
                Picture picture = drawing.createPicture(anchor, pictureIdx);
                picture.resize();

                // Create Current Gross Profit Margin Line Chart

                DefaultCategoryDataset gpDataset = new DefaultCategoryDataset();
                // Collect years and profit margins into a list
                List<Map.Entry<String, JsonNode>> entries1 = new ArrayList<>();
                profitMarginNode.fields().forEachRemaining(entries1::add);

                // Iterate over entries in reverse order to populate the dataset
                for (int i = entries1.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries1.get(i);
                    String year = entry.getKey();
                    double profitMargin = entry.getValue().asDouble();
                    gpDataset.addValue(profitMargin, "Gross Profit Margin", year);
                }

                JFreeChart gpChart = ChartFactory.createLineChart(
                        "Gross Profit Margin",
                        "",
                        "Margin (%)",
                        gpDataset,
                        PlotOrientation.VERTICAL,
                        false,
                        true,
                        false
                );
                // Customize chart properties
                gpChart.getTitle().setFont(gpChart.getTitle().getFont().deriveFont(14.0f));

                // Get the plot (where the lines are rendered) from the chart
                CategoryPlot gpPlot = gpChart.getCategoryPlot();
                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis1 = gpPlot.getDomainAxis();
                domainAxis1.setLabel("");           // Hide domain axis label
                domainAxis1.setTickLabelsVisible(true); // Show domain axis tick labels

                // Customize range axis (Y-axis) properties
                NumberAxis rangeAxis1 = (NumberAxis) gpPlot.getRangeAxis();
                rangeAxis1.setLabel("");            // Hide range axis label
                rangeAxis1.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Iterate through the dataset to find the actual minimum and maximum values
                for (int i = 0; i < gpDataset.getRowCount(); i++) {
                    for (int j = 0; j < gpDataset.getColumnCount(); j++) {
                        Number value = gpDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue < minValue) {
                                minValue = dataValue;
                            }
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }
                double profitMargin = 0.2 * (maxValue - minValue);
                rangeAxis1.setRange(minValue - profitMargin, maxValue + profitMargin);

                // Customize renderer to display values for all data points
                CategoryItemLabelGenerator gpLabelGenerator = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                LineAndShapeRenderer gpRenderer = (LineAndShapeRenderer) gpPlot.getRenderer();
                gpRenderer.setDefaultItemLabelGenerator(gpLabelGenerator);
                gpRenderer.setDefaultItemLabelsVisible(true);

                // Customize series appearance
                gpRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                gpRenderer.setSeriesStroke(0, new BasicStroke(1.5f));
                gpRenderer.setSeriesShapesVisible(0, true);
                gpRenderer.setSeriesShapesFilled(0, true);
                gpRenderer.setSeriesShape(0, new Ellipse2D.Double(-2.0, -2.0, 4.0, 4.0));
                gpRenderer.setUseFillPaint(true);

                // Set background color
                gpPlot.setBackgroundPaint(Color.WHITE);

                byte[] gpChartBytes = ChartUtils.encodeAsPNG(gpChart.createBufferedImage(400, 240));
                int gpPictureIdx = workbook.addPicture(gpChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> gpDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor gpAnchor = helper.createClientAnchor();
                gpAnchor.setCol1(7);
                gpAnchor.setRow1(0);  // Adjust row as needed
                Picture gpPicture = gpDrawing.createPicture(gpAnchor, gpPictureIdx);
                gpPicture.resize();

                // Create Current Operating Profit Margin Line Chart

                DefaultCategoryDataset opDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries2 = new ArrayList<>();
                operatingMarginNode.fields().forEachRemaining(entries2::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries2.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries2.get(i);
                    String year = entry.getKey();
                    double operatingMargin = entry.getValue().asDouble();
                    opDataset.addValue(operatingMargin, "Operating Profit Margin", year);
                }

                JFreeChart opChart = ChartFactory.createLineChart(
                        "Operating Profit Margin",
                        "",
                        "Margin (%)",
                        opDataset,
                        PlotOrientation.VERTICAL,
                        false,
                        true,
                        false
                );
                // Customize chart properties
                opChart.getTitle().setFont(opChart.getTitle().getFont().deriveFont(14.0f));

                // Get the plot (where the lines are rendered) from the chart
                CategoryPlot opPlot = opChart.getCategoryPlot();

                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis2 = opPlot.getDomainAxis();
                domainAxis2.setLabel("");           // Hide domain axis label
                domainAxis2.setTickLabelsVisible(true); // Show domain axis tick labels

                // Customize range axis (Y-axis) properties
                NumberAxis rangeAxis2 = (NumberAxis) opPlot.getRangeAxis();
                rangeAxis2.setLabel("");            // Hide range axis label
                rangeAxis2.setTickLabelsVisible(false);  // Hide range axis tick labels
                // Iterate through the dataset to find the actual minimum and maximum values
                for (int i = 0; i < opDataset.getRowCount(); i++) {
                    for (int j = 0; j < opDataset.getColumnCount(); j++) {
                        Number value = opDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue < minValue) {
                                minValue = dataValue;
                            }
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }
                double operatingMargin = 0.2 * (maxValue - minValue);
                rangeAxis2.setRange(minValue - operatingMargin, maxValue + operatingMargin);
                // Customize renderer to display values for all data points
                CategoryItemLabelGenerator labelGenerator2 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                LineAndShapeRenderer opRenderer = (LineAndShapeRenderer) opPlot.getRenderer();
                opRenderer.setDefaultItemLabelGenerator(labelGenerator2);
                opRenderer.setDefaultItemLabelsVisible(true);

                // Customize series appearance
                opRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                opRenderer.setSeriesStroke(0, new BasicStroke(1.5f));
                opRenderer.setSeriesShapesVisible(0, true);
                opRenderer.setSeriesShapesFilled(0, true);
                opRenderer.setSeriesShape(0, new Ellipse2D.Double(-2.0, -2.0, 4.0, 4.0));
                opRenderer.setUseFillPaint(true);

                // Set background color
                opPlot.setBackgroundPaint(Color.WHITE);

                byte[] opChartBytes = ChartUtils.encodeAsPNG(opChart.createBufferedImage(400, 240));
                int opPictureIdx = workbook.addPicture(opChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> opDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor opAnchor = helper.createClientAnchor();
                opAnchor.setCol1(14);
                opAnchor.setRow1(0);  // Adjust row as needed
                Picture opPicture = opDrawing.createPicture(opAnchor, opPictureIdx);
                opPicture.resize();

                // Create Current Ratio Bar Chart

                DefaultCategoryDataset cpDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries3 = new ArrayList<>();
                currentRatioNode.fields().forEachRemaining(entries3::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries3.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries3.get(i);
                    String year = entry.getKey();
                    double currentRatio = entry.getValue().asDouble();
                    cpDataset.addValue(currentRatio, "Current Ratio", year);
                }
                JFreeChart crChart = ChartFactory.createBarChart(
                        "Current Ratio",  // chart title
                        "",               // domain axis label (no specific label for this single data point)
                        "Ratio (%)",      // range axis label
                        cpDataset,        // data
                        PlotOrientation.VERTICAL,
                        false,             // include legend
                        true,             // tooltips
                        false             // urls
                );

                // Iterate through the dataset to find the actual maximum value
                for (int i = 0; i < cpDataset.getRowCount(); i++) {
                    for (int j = 0; j < cpDataset.getColumnCount(); j++) {
                        Number value = cpDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }

                double currentRatio = 0.2 * maxValue; // Adjust margin based on the maximum value
                NumberAxis rangeAxis8 = (NumberAxis) crChart.getCategoryPlot().getRangeAxis();
                double currentMinValue = rangeAxis8.getLowerBound();
                rangeAxis8.setRange(currentMinValue, maxValue + currentRatio);
                rangeAxis8.setStandardTickUnits(NumberAxis.createStandardTickUnits()); // Use standard tick units
                rangeAxis8.setNumberFormatOverride(NumberFormat.getPercentInstance());
                rangeAxis8.setLabel("");            // Hide range axis label
                rangeAxis8.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Customize chart properties
                crChart.getTitle().setFont(crChart.getTitle().getFont().deriveFont(14.0f));

                // Access the plot and renderer to adjust the bar width
                CategoryPlot plot2 = crChart.getCategoryPlot();
                BarRenderer crRenderer = (BarRenderer) plot2.getRenderer();
                CategoryItemLabelGenerator labelGenerator7 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                crRenderer.setDefaultItemLabelGenerator(labelGenerator7);
                crRenderer.setDefaultItemLabelsVisible(true); // Show item labels on bars
                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis8 = plot.getDomainAxis();
                domainAxis8.setLabel("");           // Hide domain axis label
                domainAxis8.setTickLabelsVisible(true); // Show domain axis tick labels


                // Set the bar width (adjust this value as needed)
                double maxBarWidth = 0.09;  // Adjust this value to your desired bar width
                crRenderer.setMaximumBarWidth(maxBarWidth);

                // Customize the bar color
                crRenderer.setSeriesPaint(0, new Color(44, 164, 255));

                // Optional: Set a specific bar painter (e.g., StandardBarPainter)
                crRenderer.setBarPainter(new StandardBarPainter());

                // Customize chart background color
                plot2.setBackgroundPaint(Color.WHITE);

                // Write the chart to a byte array
                byte[] crChartBytes = ChartUtils.encodeAsPNG(crChart.createBufferedImage(400, 240));

                // Add the Current Ratio chart image into the Excel file
                int crPictureIdx = workbook.addPicture(crChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> crDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor crAnchor = helper.createClientAnchor();
                crAnchor.setCol1(0);
                crAnchor.setRow1(12);  // Adjust row as needed
                Picture crPicture = crDrawing.createPicture(crAnchor, crPictureIdx);
                crPicture.resize();  // Optional: Resize the picture as needed

                // Create Debt to Equity Ratio Bar Chart

                DefaultCategoryDataset dpDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries4 = new ArrayList<>();
                ratioNode.fields().forEachRemaining(entries4::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries4.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries4.get(i);
                    String year = entry.getKey();
                    double ratio = entry.getValue().asDouble();
                    dpDataset.addValue(ratio, "Debt to Equity Ratio", year);
                }
                JFreeChart dpChart = ChartFactory.createBarChart(
                        "Debt to Equity Ratio",  // chart title
                        "",               // domain axis label (no specific label for this single data point)
                        "Ratio (%)",      // range axis label
                        dpDataset,        // data
                        PlotOrientation.VERTICAL,
                        false,             // include legend
                        true,             // tooltips
                        false             // urls
                );
                // Iterate through the dataset to find the actual maximum value
                for (int i = 0; i < dpDataset.getRowCount(); i++) {
                    for (int j = 0; j < dpDataset.getColumnCount(); j++) {
                        Number value = dpDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }

                double ratio = 0.2 * maxValue; // Adjust margin based on the maximum value
                NumberAxis rangeAxis9 = (NumberAxis) dpChart.getCategoryPlot().getRangeAxis();
                double currentMinValue1 = rangeAxis9.getLowerBound();
                rangeAxis9.setRange(currentMinValue1, maxValue + ratio);
                rangeAxis9.setStandardTickUnits(NumberAxis.createStandardTickUnits()); // Use standard tick units
                rangeAxis9.setNumberFormatOverride(NumberFormat.getPercentInstance());
                rangeAxis9.setLabel("");            // Hide range axis label
                rangeAxis9.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Customize chart properties
                dpChart.getTitle().setFont(dpChart.getTitle().getFont().deriveFont(14.0f));

                // Access the plot and renderer to adjust the bar width
                CategoryPlot dpPlot = dpChart.getCategoryPlot();
                BarRenderer dpRenderer = (BarRenderer) dpPlot.getRenderer();
                CategoryItemLabelGenerator labelGenerator8 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                dpRenderer.setDefaultItemLabelGenerator(labelGenerator8);
                dpRenderer.setDefaultItemLabelsVisible(true); // Show item labels on bars

                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis9 = plot.getDomainAxis();
                domainAxis9.setLabel("");           // Hide domain axis label
                domainAxis9.setTickLabelsVisible(true); // Show domain axis tick labels

                // Set the bar width (adjust this value as needed)
                dpRenderer.setMaximumBarWidth(maxBarWidth);
                dpRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                dpRenderer.setBarPainter(new StandardBarPainter());
                dpPlot.setBackgroundPaint(Color.WHITE);

                // Write the chart to a byte array
                byte[] dpChartBytes = ChartUtils.encodeAsPNG(dpChart.createBufferedImage(400, 240));

                // Add the Current Ratio chart image into the Excel file
                int dpPictureIdx = workbook.addPicture(dpChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> dpDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor dpAnchor = helper.createClientAnchor();
                dpAnchor.setCol1(7);
                dpAnchor.setRow1(12);  // Adjust row as needed
                Picture dpPicture = dpDrawing.createPicture(dpAnchor, dpPictureIdx);
                dpPicture.resize();  // Optional: Resize the picture as needed

                // Create Quick Ratio Bar Chart

                DefaultCategoryDataset qrDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries5 = new ArrayList<>();
                quickRatiosNode.fields().forEachRemaining(entries5::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries5.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries5.get(i);
                    String year = entry.getKey();
                    double quickRatio = entry.getValue().asDouble();
                    qrDataset.addValue(quickRatio, "Quick Ratio", year);
                }
                JFreeChart crrChart = ChartFactory.createBarChart(
                        "Quick Ratio",  // chart title
                        "",               // domain axis label (no specific label for this single data point)
                        "Ratio (%)",      // range axis label
                        qrDataset,        // data
                        PlotOrientation.VERTICAL,
                        false,             // include legend
                        true,             // tooltips
                        false             // urls
                );
                // Iterate through the dataset to find the actual maximum value
                for (int i = 0; i < cpDataset.getRowCount(); i++) {
                    for (int j = 0; j < cpDataset.getColumnCount(); j++) {
                        Number value = cpDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }

                double quickRatio = 0.2 * maxValue; // Adjust margin based on the maximum value
                NumberAxis rangeAxis10 = (NumberAxis) crrChart.getCategoryPlot().getRangeAxis();
                double currentMinValue2 = rangeAxis10.getLowerBound();
                rangeAxis10.setRange(currentMinValue2, maxValue + quickRatio);
                rangeAxis10.setStandardTickUnits(NumberAxis.createStandardTickUnits()); // Use standard tick units
                rangeAxis10.setNumberFormatOverride(NumberFormat.getPercentInstance());
                rangeAxis10.setLabel("");            // Hide range axis label
                rangeAxis10.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Customize chart properties
                crrChart.getTitle().setFont(crrChart.getTitle().getFont().deriveFont(14.0f));

                // Access the plot and renderer to adjust the bar width
                CategoryPlot crrPlot = crrChart.getCategoryPlot();
                BarRenderer crrRenderer = (BarRenderer) crrPlot.getRenderer();
                CategoryItemLabelGenerator labelGenerator9 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                crrRenderer.setDefaultItemLabelGenerator(labelGenerator9);
                crrRenderer.setDefaultItemLabelsVisible(true); // Show item labels on bars
                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis10 = crrPlot.getDomainAxis();
                domainAxis10.setLabel("");           // Hide domain axis label
                domainAxis10.setTickLabelsVisible(true); // Show domain axis tick labels
                crrRenderer.setMaximumBarWidth(maxBarWidth);

                // Customize the bar color
                crrRenderer.setSeriesPaint(0, new Color(44, 164, 255));

                // Optional: Set a specific bar painter (e.g., StandardBarPainter)
                crrRenderer.setBarPainter(new StandardBarPainter());

                // Customize chart background color
                crrPlot.setBackgroundPaint(Color.WHITE);

                // Write the chart to a byte array
                byte[] crrChartBytes = ChartUtils.encodeAsPNG(crrChart.createBufferedImage(400, 240));

                // Add the Current Ratio chart image into the Excel file
                int crrPictureIdx = workbook.addPicture(crrChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> crrDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor crrAnchor = helper.createClientAnchor();
                crrAnchor.setCol1(14);
                crrAnchor.setRow1(12);  // Adjust row as needed
                Picture crrPicture = crrDrawing.createPicture(crrAnchor, crrPictureIdx);
                crrPicture.resize();  // Optional: Resize the picture as needed

                // Create Current Operating Profit Margin Line Chart

                DefaultCategoryDataset npDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries6 = new ArrayList<>();
                marginNode.fields().forEachRemaining(entries6::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries6.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries6.get(i);
                    String year = entry.getKey();
                    double netMargin = entry.getValue().asDouble();
                    npDataset.addValue(netMargin, "Net Profit Margin", year);
                }

                JFreeChart npChart = ChartFactory.createLineChart(
                        "Net Profit Margin",
                        "",
                        "Margin (%)",
                        npDataset,
                        PlotOrientation.VERTICAL,
                        false,
                        true,
                        false
                );
                // Customize chart properties
                npChart.getTitle().setFont(npChart.getTitle().getFont().deriveFont(14.0f));
                CategoryPlot npPlot = npChart.getCategoryPlot();

                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis3 = npPlot.getDomainAxis();
                domainAxis3.setLabel("");           // Hide domain axis label
                domainAxis3.setTickLabelsVisible(true); // Show domain axis tick labels

                // Customize range axis (Y-axis) properties
                NumberAxis rangeAxis3 = (NumberAxis) npPlot.getRangeAxis();
                rangeAxis3.setLabel("");            // Hide range axis label
                rangeAxis3.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Iterate through the dataset to find the actual minimum and maximum values
                for (int i = 0; i < npDataset.getRowCount(); i++) {
                    for (int j = 0; j < npDataset.getColumnCount(); j++) {
                        Number value = npDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue < minValue) {
                                minValue = dataValue;
                            }
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }
                double netMargin = 0.2 * (maxValue - minValue);
                rangeAxis3.setRange(minValue - netMargin, maxValue + netMargin);

                // Customize renderer to display values for all data points
                CategoryItemLabelGenerator labelGenerator3 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                LineAndShapeRenderer npRenderer = (LineAndShapeRenderer) npPlot.getRenderer();
                npRenderer.setDefaultItemLabelGenerator(labelGenerator3);
                npRenderer.setDefaultItemLabelsVisible(true);

                // Customize series appearance
                npRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                npRenderer.setSeriesStroke(0, new BasicStroke(1.5f));
                npRenderer.setSeriesShapesVisible(0, true);
                npRenderer.setSeriesShapesFilled(0, true);
                npRenderer.setSeriesShape(0, new Ellipse2D.Double(-2.0, -2.0, 4.0, 4.0));
                npRenderer.setUseFillPaint(true);

                // Set background color
                npPlot.setBackgroundPaint(Color.WHITE);

                byte[] npChartBytes = ChartUtils.encodeAsPNG(npChart.createBufferedImage(400, 240));
                int npPictureIdx = workbook.addPicture(npChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> npDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor npAnchor = helper.createClientAnchor();
                npAnchor.setCol1(0);
                npAnchor.setRow1(24);  // Adjust row as needed
                Picture npPicture = npDrawing.createPicture(npAnchor, npPictureIdx);
                npPicture.resize();

                // Create Current Return on Assets (ROA) Line Chart

                DefaultCategoryDataset roaDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries7 = new ArrayList<>();
                roaNode.fields().forEachRemaining(entries7::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries7.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries7.get(i);
                    String year = entry.getKey();
                    double roa = entry.getValue().asDouble();
                    roaDataset.addValue(roa, "Return on Assets (ROA)", year);
                }

                JFreeChart roaChart = ChartFactory.createLineChart(
                        "Return on Assets (ROA)",
                        "",
                        "Margin (%)",
                        roaDataset,
                        PlotOrientation.VERTICAL,
                        false,
                        true,
                        false
                );
                // Customize chart properties
                roaChart.getTitle().setFont(roaChart.getTitle().getFont().deriveFont(14.0f));

                // Get the plot (where the lines are rendered) from the chart
                CategoryPlot roaPlot = roaChart.getCategoryPlot();

                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis4 = roaPlot.getDomainAxis();
                domainAxis4.setLabel("");           // Hide domain axis label
                domainAxis4.setTickLabelsVisible(true); // Show domain axis tick labels

                // Customize range axis (Y-axis) properties
                NumberAxis rangeAxis4 = (NumberAxis) roaPlot.getRangeAxis();
                rangeAxis4.setLabel("");            // Hide range axis label
                rangeAxis4.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Iterate through the dataset to find the actual minimum and maximum values
                for (int i = 0; i < roaDataset.getRowCount(); i++) {
                    for (int j = 0; j < roaDataset.getColumnCount(); j++) {
                        Number value = roaDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue < minValue) {
                                minValue = dataValue;
                            }
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }
                double roa = 0.2 * (maxValue - minValue);
                rangeAxis4.setRange(minValue - roa, maxValue + roa);

                // Customize renderer to display values for all data points
                CategoryItemLabelGenerator labelGenerator4 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                LineAndShapeRenderer roaRenderer = (LineAndShapeRenderer) roaPlot.getRenderer();
                roaRenderer.setDefaultItemLabelGenerator(labelGenerator4);
                roaRenderer.setDefaultItemLabelsVisible(true);

                // Customize series appearance
                roaRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                roaRenderer.setSeriesStroke(0, new BasicStroke(1.5f));
                roaRenderer.setSeriesShapesVisible(0, true);
                roaRenderer.setSeriesShapesFilled(0, true);
                roaRenderer.setSeriesShape(0, new Ellipse2D.Double(-2.0, -2.0, 4.0, 4.0));
                roaRenderer.setUseFillPaint(true);

                // Set background color
                roaPlot.setBackgroundPaint(Color.WHITE);

                byte[] roaChartBytes = ChartUtils.encodeAsPNG(roaChart.createBufferedImage(400, 240));
                int roaPictureIdx = workbook.addPicture(roaChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> roaDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor roaAnchor = helper.createClientAnchor();
                roaAnchor.setCol1(7);
                roaAnchor.setRow1(24);  // Adjust row as needed
                Picture roaPicture = roaDrawing.createPicture(roaAnchor, roaPictureIdx);
                roaPicture.resize();

                // Create Current Return on Equity (ROE) Line Chart

                DefaultCategoryDataset roeDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries8 = new ArrayList<>();
                roeNode.fields().forEachRemaining(entries8::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries8.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries8.get(i);
                    String year = entry.getKey();
                    double roe = entry.getValue().asDouble();
                    roeDataset.addValue(roe, "Return on Equity (ROE)", year);
                }

                JFreeChart roeChart = ChartFactory.createLineChart(
                        "Return on Equity (ROE)",
                        "",
                        "Margin (%)",
                        roeDataset,
                        PlotOrientation.VERTICAL,
                        false,
                        true,
                        false
                );
                // Customize chart properties
                roeChart.getTitle().setFont(roeChart.getTitle().getFont().deriveFont(14.0f));

                // Get the plot (where the lines are rendered) from the chart
                CategoryPlot roePlot = roeChart.getCategoryPlot();
                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis5 = roePlot.getDomainAxis();
                domainAxis5.setLabel("");           // Hide domain axis label
                domainAxis5.setTickLabelsVisible(true); // Show domain axis tick labels

                // Customize range axis (Y-axis) properties
                NumberAxis rangeAxis5 = (NumberAxis) roePlot.getRangeAxis();
                rangeAxis5.setLabel("");            // Hide range axis label
                rangeAxis5.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Iterate through the dataset to find the actual minimum and maximum values
                for (int i = 0; i < roeDataset.getRowCount(); i++) {
                    for (int j = 0; j < roeDataset.getColumnCount(); j++) {
                        Number value = roeDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue < minValue) {
                                minValue = dataValue;
                            }
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }
                double roe = 0.2 * (maxValue - minValue);
                rangeAxis5.setRange(minValue - roe, maxValue + roe);

                // Customize renderer to display values for all data points
                CategoryItemLabelGenerator labelGenerator5 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                LineAndShapeRenderer roeRenderer = (LineAndShapeRenderer) roePlot.getRenderer();
                roeRenderer.setDefaultItemLabelGenerator(labelGenerator5);
                roeRenderer.setDefaultItemLabelsVisible(true);

                // Customize series appearance
                roeRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                roeRenderer.setSeriesStroke(0, new BasicStroke(1.5f));
                roeRenderer.setSeriesShapesVisible(0, true);
                roeRenderer.setSeriesShapesFilled(0, true);
                roeRenderer.setSeriesShape(0, new Ellipse2D.Double(-2.0, -2.0, 4.0, 4.0));
                roeRenderer.setUseFillPaint(true);

                // Set background color
                roePlot.setBackgroundPaint(Color.WHITE);

                byte[] roeChartBytes = ChartUtils.encodeAsPNG(roeChart.createBufferedImage(400, 240));
                int roePictureIdx = workbook.addPicture(roeChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> roeDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor roeAnchor = helper.createClientAnchor();
                roeAnchor.setCol1(14);
                roeAnchor.setRow1(24);  // Adjust row as needed
                Picture roePicture = roeDrawing.createPicture(roeAnchor, roePictureIdx);
                roePicture.resize();

                // Create Interest Coverage Ratio Bar Chart

                DefaultCategoryDataset icrDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries9 = new ArrayList<>();
                icrNode.fields().forEachRemaining(entries9::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries9.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries9.get(i);
                    String year = entry.getKey();
                    double icr = entry.getValue().asDouble();
                    icrDataset.addValue(icr, "Interest Coverage Ratio", year);
                }
                JFreeChart icrChart = ChartFactory.createBarChart(
                        "Interest Coverage Ratio",  // chart title
                        "",               // domain axis label (no specific label for this single data point)
                        "Ratio (%)",      // range axis label
                        icrDataset,        // data
                        PlotOrientation.VERTICAL,
                        false,             // include legend
                        true,             // tooltips
                        false             // urls
                );
                // Iterate through the dataset to find the actual maximum value
                for (int i = 0; i < icrDataset.getRowCount(); i++) {
                    for (int j = 0; j < icrDataset.getColumnCount(); j++) {
                        Number value = icrDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue > minValue) {
                                minValue = dataValue;
                            }
                        }
                    }
                }
                double icr = 0.2 * minValue; // Adjust margin based on the maximum value
                NumberAxis rangeAxis11 = (NumberAxis) icrChart.getCategoryPlot().getRangeAxis();
                double currentMinValue4 = rangeAxis11.getLowerBound();
                rangeAxis11.setRange(currentMinValue4, minValue + icr);
                rangeAxis11.setStandardTickUnits(NumberAxis.createStandardTickUnits()); // Use standard tick units
                rangeAxis11.setNumberFormatOverride(NumberFormat.getPercentInstance());
                rangeAxis11.setLabel("");            // Hide range axis label
                rangeAxis11.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Customize chart properties
                icrChart.getTitle().setFont(icrChart.getTitle().getFont().deriveFont(14.0f));

                // Access the plot and renderer to adjust the bar width
                CategoryPlot icrPlot = icrChart.getCategoryPlot();
                BarRenderer icrRenderer = (BarRenderer) icrPlot.getRenderer();
                CategoryItemLabelGenerator labelGenerator11 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                icrRenderer.setDefaultItemLabelGenerator(labelGenerator11);
                icrRenderer.setDefaultItemLabelsVisible(true); // Show item labels on bars
                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis11 = plot.getDomainAxis();
                domainAxis11.setLabel("");           // Hide domain axis label
                domainAxis11.setTickLabelsVisible(true); // Show domain axis tick labels

                icrRenderer.setMaximumBarWidth(maxBarWidth);
                icrRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                icrRenderer.setBarPainter(new StandardBarPainter());
                icrPlot.setBackgroundPaint(Color.WHITE);

                // Write the chart to a byte array
                byte[] icrChartBytes = ChartUtils.encodeAsPNG(icrChart.createBufferedImage(400, 240));

                // Add the Current Ratio chart image into the Excel file
                int icrPictureIdx = workbook.addPicture(icrChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> icrDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor icrAnchor = helper.createClientAnchor();
                icrAnchor.setCol1(0);
                icrAnchor.setRow1(36);  // Adjust row as needed
                Picture icrPicture = icrDrawing.createPicture(icrAnchor, icrPictureIdx);
                icrPicture.resize();  // Optional: Resize the picture as needed

                // Create Operating Efficiency Ratio Line Chart

                DefaultCategoryDataset ocrDataset = new DefaultCategoryDataset();
                List<Map.Entry<String, JsonNode>> entries10 = new ArrayList<>();
                oerNode.fields().forEachRemaining(entries10::add);

                // Iterate over entries in reverse order to populate the dataset

                for (int i = entries10.size() - 1; i >= 0; i--) {
                    Map.Entry<String, JsonNode> entry = entries10.get(i);
                    String year = entry.getKey();
                    double oer = entry.getValue().asDouble();
                    ocrDataset.addValue(oer, "Operating Efficiency Ratio", year);
                }


                JFreeChart ocrChart = ChartFactory.createLineChart(
                        "Operating Efficiency Ratio",
                        "",
                        "Margin (%)",
                        ocrDataset,
                        PlotOrientation.VERTICAL,
                        false,
                        true,
                        false
                );
                // Customize chart properties
                ocrChart.getTitle().setFont(ocrChart.getTitle().getFont().deriveFont(14.0f));

                // Get the plot (where the lines are rendered) from the chart
                CategoryPlot ocrPlot = ocrChart.getCategoryPlot();

                // Customize domain axis (X-axis) properties
                CategoryAxis domainAxis6 = ocrPlot.getDomainAxis();
                domainAxis6.setLabel("");           // Hide domain axis label
                domainAxis6.setTickLabelsVisible(true); // Show domain axis tick labels

                // Customize range axis (Y-axis) properties
                NumberAxis rangeAxis6 = (NumberAxis) ocrPlot.getRangeAxis();
                rangeAxis6.setLabel("");            // Hide range axis label
                rangeAxis6.setTickLabelsVisible(false);  // Hide range axis tick labels

                // Iterate through the dataset to find the actual minimum and maximum values
                for (int i = 0; i < ocrDataset.getRowCount(); i++) {
                    for (int j = 0; j < ocrDataset.getColumnCount(); j++) {
                        Number value = ocrDataset.getValue(i, j);
                        if (value != null) {
                            double dataValue = value.doubleValue();
                            if (dataValue < minValue) {
                                minValue = dataValue;
                            }
                            if (dataValue > maxValue) {
                                maxValue = dataValue;
                            }
                        }
                    }
                }
                double oer = 0.2 * (maxValue - minValue);
                rangeAxis6.setRange(minValue - oer, maxValue + oer);

                // Customize renderer to display values for all data points
                CategoryItemLabelGenerator labelGenerator6 = new StandardCategoryItemLabelGenerator("{2}", NumberFormat.getPercentInstance());
                LineAndShapeRenderer ocrRenderer = (LineAndShapeRenderer) ocrPlot.getRenderer();
                ocrRenderer.setDefaultItemLabelGenerator(labelGenerator6);
                ocrRenderer.setDefaultItemLabelsVisible(true);

                // Customize series appearance
                ocrRenderer.setSeriesPaint(0, new Color(44, 164, 255));
                ocrRenderer.setSeriesStroke(0, new BasicStroke(1.5f));
                ocrRenderer.setSeriesShapesVisible(0, true);
                ocrRenderer.setSeriesShapesFilled(0, true);
                ocrRenderer.setSeriesShape(0, new Ellipse2D.Double(-2.0, -2.0, 4.0, 4.0));
                ocrRenderer.setUseFillPaint(true);

                // Set background color
                ocrPlot.setBackgroundPaint(Color.WHITE);

                byte[] ocrChartBytes = ChartUtils.encodeAsPNG(ocrChart.createBufferedImage(400, 240));
                int ocrPictureIdx = workbook.addPicture(ocrChartBytes, Workbook.PICTURE_TYPE_PNG);
                Drawing<?> ocrDrawing = sheet1.createDrawingPatriarch();
                ClientAnchor ocrAnchor = helper.createClientAnchor();
                ocrAnchor.setCol1(7);
                ocrAnchor.setRow1(36);  // Adjust row as needed
                Picture ocrPicture = ocrDrawing.createPicture(ocrAnchor, ocrPictureIdx);
                ocrPicture.resize();

                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                workbook.write(outputStream);
                workbook.close();

                // Upload Excel file to S3
                s3Service.uploadExcel(outputStream.toByteArray(), outputFilePath);

                return true;
            } catch (IOException e) {
                log.error("Error while transforming to XLSX: {}", e.getMessage());
                return false;
            }
        } catch (Exception e) {
            throw new RuntimeException("Error during JSON processing: " + e.getMessage());
        }
    }
    private int populateSectionWithData(Workbook workbook,Sheet sheet, int rowIndex, String sectionHeader, JsonNode dataNode, Map<String, String> keyMap) {

        // Create header row for the section
        CellStyle style = style(workbook);
        CellStyle style1 = style1(workbook);
        CellStyle style2 = style2(workbook);
        CellStyle style3 = style3(workbook);
        CellStyle boldStyle = boldStyle(workbook);
        CellStyle headerStyle = headerStyle(workbook);
        Row headerRow = sheet.createRow(rowIndex++);
        Cell headerCell = headerRow.createCell(0);
        headerCell.setCellValue(sectionHeader);
        headerCell.setCellStyle(headerStyle);
        int numDataColumns = 3;
        sheet.addMergedRegion(new CellRangeAddress(rowIndex - 1, rowIndex - 1, 0, numDataColumns)); // Merge cells from column 0 to last data column


        // Create headers for years in the next row

        Row yearRow = sheet.createRow(rowIndex++);
        int cellIndex = 1; // Start from the second cell (skip the first for labels)
        for (String year : Arrays.asList("2020", "2021", "2022")) {
            Cell yearCell = yearRow.createCell(cellIndex++);
            yearCell.setCellValue(year);
            yearCell.setCellStyle(style);
        }

        // Populate data for the section
        for (Map.Entry<String, String> entry : keyMap.entrySet()) {
            String jsonKey = entry.getKey();
            String excelLabel = entry.getValue();

            Row row = sheet.createRow(rowIndex++);
            Cell labelCell = row.createCell(0);
            labelCell.setCellValue(excelLabel);
            labelCell.setCellStyle(style1);

            cellIndex = 1; // Start from the second cell (skip the first for labels)
            for (String year : Arrays.asList("2020", "2021", "2022")) {
                JsonNode valueNode = dataNode.path(jsonKey).path(year);
                Cell valueCell = row.createCell(cellIndex++);
                valueCell.setCellValue(valueNode.asText());
                valueCell.setCellStyle(style);
            }
            if (excelLabel.equals("TOTAL ASSET") || excelLabel.equals("TOTAL LIABILITIES") || excelLabel.equals("TOTAL EQUITY") || excelLabel.equals("TOTAL LIABILITIES & EQUITY")) {
                labelCell.setCellStyle(boldStyle);
            }
            if (excelLabel.equals("Cash & Cash Equivalents") || excelLabel.equals("Accounts & Other Receivables") || excelLabel.equals("Inventory") || excelLabel.equals("Other Current Assets")|| excelLabel.equals("Property, Plant & Equipment") || excelLabel.equals("Investments") || excelLabel.equals("Other non current assets") || excelLabel.equals("Short term debt") || excelLabel.equals("Accounts Payable") || excelLabel.equals("Other Current") || excelLabel.equals("Long Term Debt") || excelLabel.equals("Other Non Current Liabilities") || excelLabel.equals("Common equity") || excelLabel.equals("Other Equity") || excelLabel.equals("Retained earning")) {
                labelCell.setCellStyle(style2);
            }
            if (excelLabel.equals("Loan receivables")) {
                labelCell.setCellStyle(style3);
            }
        }
        return rowIndex;
    }
    private static CellStyle style(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        Font font1 = workbook.createFont();
        font1.setFontName("Arial");
        font1.setFontHeightInPoints((short) 10);
        style.setAlignment(HorizontalAlignment.RIGHT);
        font1.setColor(BLACK.getIndex());
        style.setFont(font1);
        return style;
    }
    private static CellStyle style1(Workbook workbook) {
        CellStyle style1 = workbook.createCellStyle();
        Font font1 = workbook.createFont();
        font1.setFontName("Arial");
        font1.setFontHeightInPoints((short) 10);
        font1.setColor(BLACK.getIndex());
        style1.setFont(font1);
        return style1;
    }
    private static CellStyle style2(Workbook workbook) {
        CellStyle style3 = workbook.createCellStyle();
        Font font3 = workbook.createFont();
        style3.setAlignment(HorizontalAlignment.LEFT);
        style3.setIndention((short) 8);
        style3.setFont(font3);
        font3.setFontName("Arial");
        font3.setFontHeightInPoints((short) 10);
        return style3;
    }
    private static CellStyle style3(Workbook workbook) {
        CellStyle style3 = workbook.createCellStyle();
        Font font3 = workbook.createFont();
        style3.setAlignment(HorizontalAlignment.LEFT);
        style3.setIndention((short) 14);
        style3.setFont(font3);
        font3.setFontName("Arial");
        font3.setFontHeightInPoints((short) 10);
        return style3;
    }
    private static CellStyle boldStyle(Workbook workbook) {
        Font boldFont = workbook.createFont();
        boldFont.setBold(true);
        boldFont.setFontName("Arial");
        CellStyle boldStyle = workbook.createCellStyle();
        boldStyle.setFont(boldFont);
        boldFont.setFontHeightInPoints((short) 10);
        return boldStyle;
    }
    private static CellStyle headerStyle(Workbook workbook) {
        Font boldFont = workbook.createFont();
        boldFont.setBold(true);
        boldFont.setFontName("Arial");
        boldFont.setColor(WHITE.getIndex());
        CellStyle headerStyle = workbook.createCellStyle();
        headerStyle.setFont(boldFont);
        boldFont.setFontHeightInPoints((short) 10);
        headerStyle.setAlignment(HorizontalAlignment.CENTER);
        headerStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        headerStyle.setFillForegroundColor(DARK_BLUE.getIndex());
        return headerStyle;
    }
    public String transformToCsv(Map<String, Map<String, Double>> incomeSums,
            Map<String, Map<String, Double>> balanceSums,
            Map<String, Map<String, Double>> cashFlowSums) {
        String[][] lines = {
                {"", "2018", "2019", "2020", "2021", "2022", "2023"},
                {"", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"INCOME STATEMENT INPUT", "", "", "", "", "", ""},
                {"Sales", incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Sales", incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("sales", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Returns & Allowances (-)", "", "", "", "", "", ""},
                {"Other Sales", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"COGS", incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"COGS", incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("cogs", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"COGS - Depreciation", "", "", "", "", "", ""},
                {"Other COGS", "", "", "", "", "", ""},
                {"Gross Profit", incomeSums.getOrDefault("gross profit", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("gross profit", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("gross profit", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("gross profit", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("gross profit", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("gross profit", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"", "", "", "", "", "", ""},
                {"Operating Expenses", incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Operating Expenses", incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("operating expense", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Amortization", "", "", "", "", "", ""},
                {"Depreciation", "", "", "", "", "", ""},
                {"Bad Debts Written Off", "", "", "", "", "", ""},
                {"Salaries and Wages", "", "", "", "", "", ""},
                {"Officer Compensation", "", "", "", "", "", ""},
                {"Lease/Rent Expense", "", "", "", "", "", ""},
                {"Other Operating Expense", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Operating Income", incomeSums.getOrDefault("operating profit", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("operating profit", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("operating profit", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("operating profit", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("operating profit", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("operating profit", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"", "", "", "", "", "", ""},
                {"Other Expense (Income)", String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2018", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2019", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2020", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2021", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2022", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2023", 0d) * -1)},
                {"Other Expense", String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2018", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2019", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2020", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2021", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2022", 0d) * -1),
                        String.valueOf(incomeSums.getOrDefault("other expense income", new HashMap<String, Double>()).getOrDefault("2023", 0d) * -1)},
                {"Interest Income (-)", "", "", "", "", "", ""},
                {"Other Income (-)", "", "", "", "", "", ""},
                {"Sale: Fixed Assets Loss (Gain)", "", "", "", "", "", ""},
                {"Gain on Derivatives (-)", "", "", "", "", "", ""},
                {"Loss on Derivatives", "", "", "", "", "", ""},
                {"Income from Subsidiaries/Other (-)", "", "", "", "", "", ""},
                {"Non Cash Income (-)", "", "", "", "", "", ""},
                {"Non Cash Expenses", "", "", "", "", "", ""},
                {"Other Expenses (Income)", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"EBIT", incomeSums.getOrDefault("ebit", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("ebit", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("ebit", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("ebit", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("ebit", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("ebit", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"", "", "", "", "", "", ""},
                {"Interest Expense", incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Interest Expense", incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("interest expense", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Deferred Interest", "", "", "", "", "", ""},
                {"Capitalized Interest (-)", "", "", "", "", "", ""},
                {"Interest Expense: Debt Maturity Profile", "", "", "", "", "", ""},
                {"Other Interest Expense", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Profit Before Tax", incomeSums.getOrDefault("profit before tax", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("profit before tax", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("profit before tax", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("profit before tax", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("profit before tax", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("profit before tax", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"", "", "", "", "", "", ""},
                {"Taxes",
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2018", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2019", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2020", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2021", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2022", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2023", 0d) * -1))},
                {"Taxes",
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2018", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2019", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2020", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2021", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2022", 0d) * -1)),
                        String.valueOf((incomeSums.getOrDefault("taxes", new HashMap<String, Double>()).getOrDefault("2023", 0d) * -1))},
                {"Deferred Income Tax", "", "", "", "", "", ""},
                {"Income Tax Credit (-)", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Other Taxes", incomeSums.getOrDefault("other taxes", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("other taxes", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("other taxes", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("other taxes", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("other taxes", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("other taxes", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Non-Tax Expenses (Income)", "", "", "", "", "", ""},
                {"Non-Tax Expenses (Income)", "", "", "", "", "", ""},
                {"Extraordinary Items", "", "", "", "", "", ""},
                {"Minority Interest (-)", "", "", "", "", "", ""},
                {"Other Non-Tax Expenses (Income)", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Net Income", incomeSums.getOrDefault("net income", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("net income", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("net income", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("net income", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("net income", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("net income", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"", "", "", "", "", "", ""},
                {"Dividends", incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Dividends", incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("dividends", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Cash Dividends", "", "", "", "", "", ""},
                {"Stock Dividends", "", "", "", "", "", ""},
                {"Other Non Cash Dividends", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Adjustments (+) / -", incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Adjustments", incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("adjustments", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"Other Adjustments", "", "", "", "", "", ""},
                {"Retained Earnings", incomeSums.getOrDefault("retained earnings", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        incomeSums.getOrDefault("retained earnings", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        incomeSums.getOrDefault("retained earnings", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        incomeSums.getOrDefault("retained earnings", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        incomeSums.getOrDefault("retained earnings", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        incomeSums.getOrDefault("retained earnings", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},
                {"", "", "", "", "", "", ""},
                {"BALANCE SHEET INPUT", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Cash & Cash Equivalents", balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Cash & Cash Equivalents", balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Short Term Liquid Deposits", "", "", "", "", "", ""},
                {"Marketable Securities", "", "", "", "", "", ""},
                {"Other Cash & Cash Equivalents", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Accounts & Other Receivables", balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Accounts & Other Receivables", balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Trade Receivable", "", "", "", "", "", ""},
                {"Other Accounts & Receivables", "", "", "", "", "", ""},
                {"Allowance: Doubtful Accounts (-)", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Inventory", balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Inventory", balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Raw Materials/Stock", "", "", "", "", "", ""},
                {"Work in Progress", "", "", "", "", "", ""},
                {"Finished Goods/Services", "", "", "", "", "", ""},
                {"Other Inventory", "", "", "", "", "", ""},
                {"Provision: Slow Moving/Objects (-)", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Other Current Assets", balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Other Current Assets", balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Tax Receivable", "", "", "", "", "", ""},
                {"Notes Receivable", "", "", "", "", "", ""},
                {"Non Trade Receivables", "", "", "", "", "", ""},
                {"Prepaid Expenses", "", "", "", "", "", ""},
                {"Loans to Related Parties (current)", "", "", "", "", "", ""},
                {"Deferred Tax Recovery (current)", "", "", "", "", "", ""},
                {"Due from Related Parties (current)", "", "", "", "", "", ""},
                {"Costs in Excess of Billings", "", "", "", "", "", ""},
                {"Derivative Assets (current)", "", "", "", "", "", ""},
                {"Non Operating Current Assets", "", "", "", "", "", ""},
                {"Other Current Assets", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Current Assets",
                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2018", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2019", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2020", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2021", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2022", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2023", 0d)))},

                {"", "", "", "", "", "", ""},
                {"Property Plant & Equipment", balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Property Plant & Equipment", balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Land", "", "", "", "", "", ""},
                {"Buildings", "", "", "", "", "", ""},
                {"Leasehold Improvements", "", "", "", "", "", ""},
                {"Equipment", "", "", "", "", "", ""},
                {"Vehicles", "", "", "", "", "", ""},
                {"Furniture & Fixtures", "", "", "", "", "", ""},
                {"Other PP&E", "", "", "", "", "", ""},
                {"Construction Work in Progress", "", "", "", "", "", ""},
                {"Accumulated Depreciation (-)", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Investments", balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Investments", balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Investment in Equity", "", "", "", "", "", ""},
                {"Other Investments", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Other Non Current Assets", balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Other Non Current Assets", balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Intangibles", "", "", "", "", "", ""},
                {"Goodwill", "", "", "", "", "", ""},
                {"Other Intangibles", "", "", "", "", "", ""},
                {"Notes Receivable (non current)", "", "", "", "", "", ""},
                {"Deferred Tax", "", "", "", "", "", ""},
                {"Loans to Related Parties (non current)", "", "", "", "", "", ""},
                {"Prepaid/Deferred Expenses (non current)", "", "", "", "", "", ""},
                {"Cash Value Life Insurance", "", "", "", "", "", ""},
                {"Derivative Assets (non current)", "", "", "", "", "", ""},
                {"Non Current Non Operating", "", "", "", "", "", ""},
                {"Other Non Current Assets", "", "", "", "", "", ""},
                {"Accumulated Amortization (-)", "", "", "", "", "", ""},
                {"Non Current Assets", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Total Assets",
                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2018", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2019", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2020", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2021", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2022", 0d))),

                        String.valueOf((balanceSums.getOrDefault("cash & cash equivalents", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("accounts & other receivables", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("inventory", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other current assets", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("property, plant & equipment", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("investments", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other non current assets", new HashMap<String, Double>()).getOrDefault("2023", 0d)))},

                {"", "", "", "", "", "", ""},
                {"Short Term Debt", balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Short Term Debt", balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Current Maturity LTD", "", "", "", "", "", ""},
                {"Capital Leases (current)", "", "", "", "", "", ""},
                {"Subordinated Debt (current)", "", "", "", "", "", ""},
                {"Overdraft", "", "", "", "", "", ""},
                {"Line of Credit", "", "", "", "", "", ""},
                {"Loans Payable Other", "", "", "", "", "", ""},
                {"Other Short Term Debt", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Accounts Payable", balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Accounts Payable", balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Trade Payable", "", "", "", "", "", ""},
                {"Trust Receipts Payable ", "", "", "", "", "", ""},
                {"Other Accounts Payable", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Other Current Liabilities", balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Other Current Liabilities", balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Accruals", "", "", "", "", "", ""},
                {"Tax Payable", "", "", "", "", "", ""},
                {"Dividends Payable", "", "", "", "", "", ""},
                {"Interest Payable", "", "", "", "", "", ""},
                {"Provisions", "", "", "", "", "", ""},
                {"Due to Related Parties (current)", "", "", "", "", "", ""},
                {"Non Trade Creditors", "", "", "", "", "", ""},
                {"Billings in Excess of Costs", "", "", "", "", "", ""},
                {"Deferred Tax (current)", "", "", "", "", "", ""},
                {"Loans from Related Company (current)", "", "", "", "", "", ""},
                {"Derivative Liabilities (current)", "", "", "", "", "", ""},
                {"Non Operating Current Liabilities", "", "", "", "", "", ""},
                {"Other Current Liabilities", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Current Liabilities",
                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2018", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2019", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2020", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2021", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2022", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2023", 0d))},

                {"", "", "", "", "", "", ""},
                {"Long Term Debt", balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Long Term Debt", balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Long Term Capital Lease", "", "", "", "", "", ""},
                {"Long Term Subordinated Debt", "", "", "", "", "", ""},
                {"Deferred Debt", "", "", "", "", "", ""},
                {"Deferred Interest", "", "", "", "", "", ""},
                {"Other Long Term Debt", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Other Non Current Liabilities", balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Other Non Current Liabilities", balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Deferred Tax (non current)", "", "", "", "", "", ""},
                {"Due to Related Parties (non current)", "", "", "", "", "", ""},
                {"Provisions", "", "", "", "", "", ""},
                {"Minority Interest/GAAP", "", "", "", "", "", ""},
                {"Deferred Revenue", "", "", "", "", "", ""},
                {"Loans from Related Company (non current)", "", "", "", "", "", ""},
                {"Derivative Liabilities (non current)", "", "", "", "", "", ""},
                {"Non Operating Non Current Liabilities", "", "", "", "", "", ""},
                {"Other Non Current Liabiilities", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Non Current Liabilities",
                        String.valueOf(balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2018", 0d)),

                        String.valueOf(balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2019", 0d)),

                        String.valueOf(balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2020", 0d)),

                        String.valueOf(balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2021", 0d)),

                        String.valueOf(balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2022", 0d)),

                        String.valueOf(balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2023", 0d))},

                {"", "", "", "", "", "", ""},
                {"Total Liabilities",
                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2018", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2019", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2020", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2021", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2022", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2023", 0d))},

                {"", "", "", "", "", "", ""},
                {"Stockholding", balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Stockholding", balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Preferred Shares", "", "", "", "", "", ""},
                {"Common Shares", "", "", "", "", "", ""},
                {"Paid In Capital", "", "", "", "", "", ""},
                {"Other Stockholding", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Other Equity", balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Other Equity", balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Stockholders Loans", "", "", "", "", "", ""},
                {"Minority Interest/IFRS", "", "", "", "", "", ""},
                {"Reserves", "", "", "", "", "", ""},
                {"Treasury Stock (-)", "", "", "", "", "", ""},
                {"Subordinated Debt/Equity", "", "", "", "", "", ""},
                {"Accumulated OCI", "", "", "", "", "", ""},
                {"Other Equity", "", "", "", "", "", ""},
                {"Currency Adjustment", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Accumulated R/E", balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"Retained Earnings from I/S", "", "", "", "", "", ""},
                {"Previous Balance", "", "", "", "", "", ""},
                {"Adjustments", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"Total Equity",
                        String.valueOf(balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2018", 0d)),

                        String.valueOf(balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2019", 0d)),

                        String.valueOf(balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2020", 0d)),

                        String.valueOf(balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2021", 0d)),

                        String.valueOf(balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2022", 0d)),

                        String.valueOf(balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2023", 0d))},

                {"Total Liabilities & Equity",
                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2018", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2018", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2019", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2019", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2020", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2020", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2021", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2021", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2022", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2022", 0d)),

                        String.valueOf(balanceSums.getOrDefault("short term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("accounts payable", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other current", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("long term debt", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other non current liabilities", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("stockholding", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("other equity", new HashMap<String, Double>()).getOrDefault("2023", 0d) +
                                balanceSums.getOrDefault("accumulated", new HashMap<String, Double>()).getOrDefault("2023", 0d))},

                {"", "", "", "", "", "", ""},
                {"CASHFLOW MAPPING", "", "", "", "", "", ""},
                {"FUNDS FROM OPERATIONS", "", "", "", "", "", ""},
                {"Operating Income", "", "", "", "", "", ""},
                {"Add: Depreciation and Amortization", "", "", "", "", "", ""},
                {"Other Income (Expenses)", "", "", "", "", "", ""},
                {"Less: Provision for Income Tax", "", "", "", "", "", ""},
                {"CASHFLOW FROM OPERATIONS",
                        cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"", "", "", "", "", "", ""},
                {"FUNDS FROM WORKING CAPITAL", "", "", "", "", "", ""},
                {"(Increase)/Decrease in:", "", "", "", "", "", ""},
                {"Marketable Securities", "", "", "", "", "", ""},
                {"Accounts & Other Receivables", "", "", "", "", "", ""},
                {"Trade Receivable", "", "", "", "", "", ""},
                {"Other Accounts & Receivables", "", "", "", "", "", ""},
                {"Allowance: Doubtful Accounts (-)", "", "", "", "", "", ""},
                {"Inventory", "", "", "", "", "", ""},
                {"Raw Materials/Stock", "", "", "", "", "", ""},
                {"Work in Progress", "", "", "", "", "", ""},
                {"Finished Goods/Services", "", "", "", "", "", ""},
                {"Other Inventory", "", "", "", "", "", ""},
                {"Provision: Slow Moving/Objects (-)", "", "", "", "", "", ""},
                {"Other Current Assets", "", "", "", "", "", ""},
                {"Tax Receivable", "", "", "", "", "", ""},
                {"Notes Receivable", "", "", "", "", "", ""},
                {"Non Trade Receivables", "", "", "", "", "", ""},
                {"Prepaid Expenses", "", "", "", "", "", ""},
                {"Loans to Related Parties (current)", "", "", "", "", "", ""},
                {"Deferred Tax Recovery (current)", "", "", "", "", "", ""},
                {"Due from Related Parties (current)", "", "", "", "", "", ""},
                {"Costs in Excess of Billings", "", "", "", "", "", ""},
                {"Derivative Assets (current)", "", "", "", "", "", ""},
                {"Non Operating Current Assets", "", "", "", "", "", ""},
                {"Other Current Assets", "", "", "", "", "", ""},
                {"Increase/(Decrease) in:", "", "", "", "", "", ""},
                {"Accounts Payable", "", "", "", "", "", ""},
                {"Trade Payable", "", "", "", "", "", ""},
                {"Trust Receipts Payable ", "", "", "", "", "", ""},
                {"Other Accounts Payable", "", "", "", "", "", ""},
                {"Other Current Liabilities", "", "", "", "", "", ""},
                {"Accruals", "", "", "", "", "", ""},
                {"Tax Payable", "", "", "", "", "", ""},
                {"Dividends Payable", "", "", "", "", "", ""},
                {"Interest Payable", "", "", "", "", "", ""},
                {"Provisions", "", "", "", "", "", ""},
                {"Due to Related Parties (current)", "", "", "", "", "", ""},
                {"Non Trade Creditors", "", "", "", "", "", ""},
                {"Billings in Excess of Costs", "", "", "", "", "", ""},
                {"Deferred Tax (current)", "", "", "", "", "", ""},
                {"Loans from Related Company (current)", "", "", "", "", "", ""},
                {"Derivative Liabilities (current)", "", "", "", "", "", ""},
                {"Non Operating Current Liabilities", "", "", "", "", "", ""},
                {"Other Current Liabilities", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"CASHFLOW FROM WORKING CAPITAL",
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2018", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2018", 0d) - cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2018", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2019", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2019", 0d) - cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2019", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2020", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2020", 0d) - cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2020", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2021", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2021", 0d) - cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2021", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2022", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2022", 0d) - cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2022", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2023", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2023", 0d) - cashFlowSums.getOrDefault("cashflow from operations", new HashMap<String, Double>()).getOrDefault("2023", 0d))},
                {"", "", "", "", "", "", ""},
                {"NET OPERATING CASH GENERATED",
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2018", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2018", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2019", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2019", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2020", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2020", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2021", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2021", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2022", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2022", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2023", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2023", 0d))},

                {"", "", "", "", "", "", ""},
                {"FUNDS FROM NON-WORKING CAPITAL", "", "", "", "", "", ""},
                {"(Increase)/Decrease in:", "", "", "", "", "", ""},
                {"Property Plant & Equipment", "", "", "", "", "", ""},
                {"Land", "", "", "", "", "", ""},
                {"Buildings", "", "", "", "", "", ""},
                {"Leasehold Improvements", "", "", "", "", "", ""},
                {"Equipment", "", "", "", "", "", ""},
                {"Vehicles", "", "", "", "", "", ""},
                {"Furniture & Fixtures", "", "", "", "", "", ""},
                {"Other PP&E", "", "", "", "", "", ""},
                {"Construction Work in Progress", "", "", "", "", "", ""},
                {"Investments", "", "", "", "", "", ""},
                {"Other Non Current Assets", "", "", "", "", "", ""},
                {"Increase/(Decrease) in:", "", "", "", "", "", ""},
                {"Other Non Current Liabilities", "", "", "", "", "", ""},
                {"Deferred Tax (non current)", "", "", "", "", "", ""},
                {"Due to Related Parties (non current)", "", "", "", "", "", ""},
                {"Provisions", "", "", "", "", "", ""},
                {"Minority Interest/GAAP", "", "", "", "", "", ""},
                {"Deferred Revenue", "", "", "", "", "", ""},
                {"Loans from Related Company (non current)", "", "", "", "", "", ""},
                {"Derivative Liabilities (non current)", "", "", "", "", "", ""},
                {"Non Operating Non Current Liabilities", "", "", "", "", "", ""},
                {"Other Non Current Liabiilities", "", "", "", "", "", ""},
                {"Stockholding", "", "", "", "", "", ""},
                {"Preferred Shares", "", "", "", "", "", ""},
                {"Common Shares", "", "", "", "", "", ""},
                {"Paid In Capital", "", "", "", "", "", ""},
                {"Other Stockholding", "", "", "", "", "", ""},
                {"Other Equity", "", "", "", "", "", ""},
                {"Stockholders Loans", "", "", "", "", "", ""},
                {"Minority Interest/IFRS", "", "", "", "", "", ""},
                {"Reserves", "", "", "", "", "", ""},
                {"Treasury Stock (-)", "", "", "", "", "", ""},
                {"Subordinated Debt/Equity", "", "", "", "", "", ""},
                {"Accumulated OCI", "", "", "", "", "", ""},
                {"Other Equity", "", "", "", "", "", ""},
                {"Adjustments", "", "", "", "", "", ""},
                {"Currency Adjustment", "", "", "", "", "", ""},
                {"Dividends paid", "", "", "", "", "", ""},
                {"CASHFLOW FROM NON-WORKING CAPITAL",
                        cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"", "", "", "", "", "", ""},
                {"CASHFLOW BEFORE DEBT SERVICE",
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2018", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2018", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2018", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2019", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2019", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2019", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2020", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2020", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2020", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2021", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2021", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2021", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2022", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2022", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2022", 0d)),
                        String.valueOf(cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2023", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2023", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2023", 0d))},

                {"", "", "", "", "", "", ""},
                {"DEBT SERVICE",
                        String.valueOf(cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2018", 0d) - (cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2018", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2018", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2018", 0d))),
                        String.valueOf(cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2019", 0d) - (cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2019", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2019", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2019", 0d))),
                        String.valueOf(cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2020", 0d) - (cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2020", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2020", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2020", 0d))),
                        String.valueOf(cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2021", 0d) - (cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2021", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2021", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2021", 0d))),
                        String.valueOf(cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2022", 0d) - (cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2022", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2022", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2022", 0d))),
                        String.valueOf(cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2023", 0d) - (cashFlowSums.getOrDefault("net operating cash", new HashMap<String, Double>()).getOrDefault("2023", 0d) - cashFlowSums.getOrDefault("interest paid", new HashMap<String, Double>()).getOrDefault("2023", 0d) + cashFlowSums.getOrDefault("cashflow from non-working capital", new HashMap<String, Double>()).getOrDefault("2023", 0d)))},

                {"Principal (Payment) / Drawing", "", "", "", "", "", ""},
                {"Interest", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"", "", "", "", "", "", ""},
                {"CASHFLOW AFTER DEBT SERVICE",
                        cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        cashFlowSums.getOrDefault("cashflow after debt service", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

                {"", "", "", "", "", "", ""},
                {"BEGINNING CASH",
                        cashFlowSums.getOrDefault("beginning cash", new HashMap<String, Double>()).getOrDefault("2018", 0d).toString(),
                        cashFlowSums.getOrDefault("beginning cash", new HashMap<String, Double>()).getOrDefault("2019", 0d).toString(),
                        cashFlowSums.getOrDefault("beginning cash", new HashMap<String, Double>()).getOrDefault("2020", 0d).toString(),
                        cashFlowSums.getOrDefault("beginning cash", new HashMap<String, Double>()).getOrDefault("2021", 0d).toString(),
                        cashFlowSums.getOrDefault("beginning cash", new HashMap<String, Double>()).getOrDefault("2022", 0d).toString(),
                        cashFlowSums.getOrDefault("beginning cash", new HashMap<String, Double>()).getOrDefault("2023", 0d).toString()},

        };
        StringBuilder csvContent = new StringBuilder();
        for (String[] line: lines) {
            String parts = line[0] + "," + line[1] + "," + line[2] + "," + line[3] + "," + line[4] + "," + line[5] + "," + line[6];
            csvContent.append(parts).append("\n");
        }

        return csvContent.toString();
    }

    private static Map<String, Map<String, String>> formatValuesToString(Map<String, Map<String, Double>> keywordYearSums) {
        Map<String, Map<String, String>> formattedKeywordYearSums = new HashMap<>();
        for (Map.Entry<String, Map<String, Double>> keywordEntry : keywordYearSums.entrySet()) {
            Map<String, String> formattedYearSums = new HashMap<>();
            for (Map.Entry<String, Double> yearEntry : keywordEntry.getValue().entrySet()) {
                String formattedSum = String.format("%,.2f", yearEntry.getValue());
                formattedYearSums.put(yearEntry.getKey(), formattedSum);
            }
            formattedKeywordYearSums.put(keywordEntry.getKey(), formattedYearSums);
        }
        return formattedKeywordYearSums;
    }

    @Value
    @Builder(toBuilder = true)
    @AllArgsConstructor
    @Jacksonized
    public static class TransformedResult {
        Double currentRatio;
        Double quickRatio;

        Double netProfitMargin;
        Double returnOnAssets;
        Double returnOnEquity;
        Double grossMargin;

        Double inventoryTurnover;
        Double receivableTurnover;
        Double assetTurnover;

        Double debtToEquityRatio;
        Double interestCoverageRatio;
        Double cashFlowCoverageRatio;
    }

    private Optional<Double> getCashFlowCoverageRatio(JsonNode cashFlows, JsonNode currentLiabilities, String year) {
        Double operatingCF = null;
        Double totalNonCurrentLiabilities = null;

        if (cashFlows == null || currentLiabilities == null) return Optional.empty();

        if (cashFlows.isArray()) {
            for (JsonNode item: cashFlows) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("net cash provided by (used in) operating activities")) {
                    operatingCF = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (currentLiabilities.isArray()) {
            for (JsonNode item: currentLiabilities) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total non-current liabilities")) {
                    totalNonCurrentLiabilities = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (operatingCF == null || totalNonCurrentLiabilities == null)
            return Optional.empty();

        return Optional.of(round(operatingCF / totalNonCurrentLiabilities));
    }

    private Optional<Double> getInterestCoverageRatio(JsonNode retainedEarnings, String year) {
        Double netIncome = null;
        Double financeCost = null;

        if (retainedEarnings == null) return Optional.empty();

        if (retainedEarnings.isArray()) {
            for (JsonNode item: retainedEarnings) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("profit/(loss) before tax")) {
                    netIncome = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                    continue;
                }

                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("finance cost")) {
                    financeCost = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (netIncome == null || financeCost == null)
            return Optional.empty();

        return Optional.of(round((netIncome + financeCost) / financeCost));
    }

    private Optional<Double> getDebtToEquityRatio(JsonNode currentLiabilities, JsonNode equity, String year) {
        Double totalShareholdersEquity = null;
        Double totalNonCurrentLiabilities = null;

        if (currentLiabilities == null || equity == null) return Optional.empty();

        if (equity.isArray()) {
            for (JsonNode item: equity) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total stockholders' equity")) {
                    totalShareholdersEquity = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (currentLiabilities.isArray()) {
            for (JsonNode item: currentLiabilities) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total non-current liabilities")) {
                    totalNonCurrentLiabilities = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                    break;
                }
            }
        }

        if (totalShareholdersEquity == null || totalNonCurrentLiabilities == null)
            return Optional.empty();

        return Optional.of(round(totalNonCurrentLiabilities / totalShareholdersEquity));

    }

    private Optional<Double> getGrossMargin(JsonNode retainedEarnings, String year) {
        Double revenue = null;
        Double costOfServices = null;

        if (retainedEarnings == null) return Optional.empty();

        if (retainedEarnings.isArray()) {
            for (JsonNode item: retainedEarnings) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("revenue")) {
                    revenue = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                    continue;
                }

                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("cost of services")) {
                    costOfServices = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (revenue == null || costOfServices == null) return Optional.empty();

        return Optional.of(round2(((revenue - costOfServices) / revenue) * 100));

    }

    private Optional<Double> getReturnOnEquity(JsonNode retainedEarnings, JsonNode equity, String year) {
        Double netIncome = null;
        Double avgShareholdersEquity = null;

        if (retainedEarnings == null || equity == null) return Optional.empty();

        if (retainedEarnings.isArray()) {
            for (JsonNode item: retainedEarnings) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("profit/(loss) for the year")) {
                    netIncome = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (equity.isArray()) {
            for (JsonNode item: equity) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total stockholders' equity")) {
                    Double year1 = parseDouble(item.get("2021").asText().replaceAll("[()P]", "").trim());
                    Double year2 = parseDouble(item.get("2022").asText().replaceAll("[()P]", "").trim());
                    if (year1 != null && year2 != null) {
                        avgShareholdersEquity = (year1 + year2) / 2;
                        break;
                    }
                }
            }
        }

        if (netIncome == null || avgShareholdersEquity == null) return Optional.empty();

        return Optional.of(round(netIncome / avgShareholdersEquity));

    }

    private Optional<Double> getReturnOnAssets(JsonNode totalAssets, JsonNode retainedEarnings, String year) {
        Double netIncome = null;
        Double avgTotalAssets = null;

        if (totalAssets == null || retainedEarnings == null) return Optional.empty();


        if (retainedEarnings.isArray()) {
            for (JsonNode item: retainedEarnings) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("profit/(loss) for the year")) {
                    netIncome = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (totalAssets.isArray()) {
            for (JsonNode item: totalAssets) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total assets")) {
                    Double year1 = parseDouble(item.get("2021").asText().replaceAll("[()P]", "").trim());
                    Double year2 = parseDouble(item.get("2022").asText().replaceAll("[()P]", "").trim());
                    if (year1 != null && year2 != null) {
                        avgTotalAssets = (year1 + year2) / 2;
                        break;
                    }
                }
            }
        }

        if (netIncome == null || avgTotalAssets == null) return Optional.empty();

        return Optional.of(round(netIncome / avgTotalAssets));

    }

    private Optional<Double> getNetProfitMargin(JsonNode retainedEarnings, String year) {
        Double netIncome = null;
        Double revenue = null;

        if (retainedEarnings == null) return Optional.empty();

        if (retainedEarnings.isArray()) {
            for (JsonNode item: retainedEarnings) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("profit/(loss) for the year")) {
                    netIncome = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("revenue")) {
                    revenue = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (netIncome == null || revenue == null) return Optional.empty();

        return Optional.of(round((netIncome / revenue) * 100));
    }

    private Optional<Double> getQuickRatio(JsonNode currentAssets, JsonNode currentLiabilities, String year) {
        Double totalCurrentAssets = null;
        Double totalCurrentLiabilities = null;
        Double totalInventory = null;

        if (currentAssets == null || currentLiabilities == null) return Optional.empty();

        if (currentAssets.isArray()) {
            for (JsonNode item: currentAssets) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total current assets")) {
                    totalCurrentAssets = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                    continue;
                }

                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("inventory")) {
                    totalInventory = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                }
            }
        }

        if (currentLiabilities.isArray()) {
            for (JsonNode item: currentLiabilities) {
                String text = item.get("key").asText().toLowerCase().trim();
                if (text.contains("total current liabilities")
                        || text.contains("total liabilities")
                        || text.contains("total liabilites")) {
                    totalCurrentLiabilities = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                    break;
                }
            }
        }

        if (totalCurrentAssets == null || totalCurrentLiabilities == null || totalInventory == null)
            return Optional.empty();

        return Optional.of(round((totalCurrentAssets - totalInventory) / totalCurrentLiabilities));

    }

    private Optional<Double> getCurrentRatio(JsonNode currentAssets, JsonNode currentLiabilities, String year) {
        Double totalCurrentAssets = null;
        Double totalCurrentLiabilities = null;

        if (currentAssets == null || currentLiabilities == null) return Optional.empty();

        if (currentAssets.isArray()) {
            for (JsonNode item: currentAssets) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total current assets")) {
                    totalCurrentAssets = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                    break;
                }
            }
        }

        if (currentLiabilities.isArray()) {
            for (JsonNode item: currentLiabilities) {
                if (item.has("key") && item.get("key").asText().toLowerCase().trim().contains("total current liabilities")) {
                    totalCurrentLiabilities = parseDouble(item.get(year).asText().replaceAll("[()P]", "").trim());
                    break;
                }
            }
        }

        if (totalCurrentAssets == null || totalCurrentLiabilities == null) return Optional.empty();

        return Optional.of(round(totalCurrentAssets / totalCurrentLiabilities));
    }

    private double round(double value) {
        return BigDecimal.valueOf(value).setScale(2, RoundingMode.HALF_UP).doubleValue();
    }

    private double round2(double value) {
        return Math.ceil(value);
    }

    public String toJson(TransformedResult transformedResult) {
        try {
            return getObjectMapper().writeValueAsString(transformedResult);
        } catch (IOException ex) {
            log.warn("Failed to transform Financial Statement transformed result to JSON: {}", transformedResult, ex);
            return null;
        }
    }
}

